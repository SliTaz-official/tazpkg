#!/bin/sh
#
# TazPkg - Tiny autonomous zone packages manager.
#
# This is a lightweight packages manager for *.tazpkg files written in SHell
# script. It works well with Busybox ash shell and bash. TazPkg lets you
# list, install, remove, download or get information about a package. You
# can use 'tazpkg usage' to get a list of commands with short descriptions.
# TazPkg also resolves dependencies and can upgrade packages from a mirror.
#
# (C) 2007-2015 SliTaz - GNU General Public License v3.
#
# Authors: See the AUTHORS files
#


####################
# Script variables #
####################

. /etc/slitaz/slitaz.conf
. /etc/slitaz/tazpkg.conf

. /lib/libtaz.sh
. /usr/lib/slitaz/libpkg.sh
. /usr/lib/tazpkg/tazpkg-find-depends

# Internationalization.
export TEXTDOMAIN='tazpkg'
_()  { local T="$1"; shift; printf "$(gettext "$T")" "$@"; echo; }
_n() { local T="$1"; shift; printf "$(gettext "$T")" "$@"; }
_p() {
	local S="$1" P="$2" N="$3"; shift 3;
	printf "$(ngettext "$S" "$P" "$N")" "$@"; }


#
# Functions set for translate categories
#


# Make array of pre-translated categories

cat_i18n=''
for c in 'base-system' 'x-window' 'utilities' 'network' 'graphics' \
	'multimedia' 'office' 'development' 'system-tools' 'security' 'games' \
	'misc' 'meta' 'non-free'; do
	cat_i18n="$cat_i18n
$(gettext "$c")	$c"
done


# Translate category names (must be last in line)

translate_category() {
	sed "s|base-system$|$(_ base-system)|g; s|x-window$|$(_ x-window)|g;
		s|utilities$|$(_ utilities)|g; s|network$|$(_ network)|g;
		s|graphics$|$(_ graphics)|g; s|multimedia$|$(_ multimedia)|g;
		s|office$|$(_ office)|g; s|development$|$(_ development)|g;
		s|system-tools$|$(_ system-tools)|g; s|security$|$(_ security)|g;
		s|games$|$(_ games)|g; s|misc$|$(_ misc)|g; s|meta$|$(_ meta)|g;
		s|non-free$|$(_ non-free)|g"
}


# If category is not one of those translated in native language, keep it
# untranslated. This allows both native and English language support.
# This also supports custom categories.
# And now we support spaces in translated categories

reverse_translate_category() {
	echo "$cat_i18n" | awk "BEGIN{FS=\"	\"}{if (/^$@	/) a=\$2}END{if (a==\"\") a=\"$@\"; print a}"
}




# Initialize some variables to use words rather than numbers for functions
# and actions.

COMMAND="$1"
PACKAGE="${2%/}"
PACKAGE_DIR="$(cd $(dirname "$PACKAGE" 2>/dev/null) 2>/dev/null; pwd)"
[ -n "$PACKAGE" ] && PACKAGE_FILE="$PACKAGE_DIR/${PACKAGE##*/}"
if [ -f "$PACKAGE" ]; then
	# Set pkg basename for install, extract
	PACKAGE="$(basename "$PACKAGE" .tazpkg 2>/dev/null)"
else
	# Pkg name for remove, search and all other cmds
	PACKAGE="${PACKAGE%.tazpkg}"
fi
TARGET_DIR="$3"
TOP_DIR="$(pwd)"
TMP_DIR="/tmp/$RANDOM"
INSTALL_LIST=''
SAVE_CACHE_DIR="$CACHE_DIR"

# Path to tazpkg used dir and configuration files
MIRROR="$PKGS_DB/mirror"
BLOCKED="$PKGS_DB/blocked-packages.list"
UP_LIST="$PKGS_DB/packages.up"
DEFAULT_MIRROR="$ONLINE_PKGS"

# TazPkg version
VERSION=$(awk -F$'\t' '$1=="tazpkg"{print $2}' $PKGS_DB/installed.info)
# User Agent
UA="TazPkg-$VERSION"

#title 'DEBUG'; emsg "<b>COMMAND</b>=\"$COMMAND\"\n<b>PACKAGE</b>=\"$PACKAGE\"\n<b>PACKAGE_FILE</b>=\"$PACKAGE_FILE\"\n<b>TARGET_DIR</b>=\"$TARGET_DIR\"\n<b>TOP_DIR</b>=\"$TOP_DIR\"\n<b>TMP_DIR</b>=\"$TMP_DIR\"\n<b>INSTALL_LIST</b>=\"$INSTALL_LIST\"\n<b>SAVE_CACHE_DIR</b>=\"$SAVE_CACHE_DIR\"\n<b>MIRROR</b>=\"$MIRROR\"\n<b>BLOCKED</b>=\"$BLOCKED\"\n<b>UP_LIST</b>=\"$UP_LIST\"\n<b>DEFAULT_MIRROR</b>=\"$DEFAULT_MIRROR\"\n<b>VERSION</b>=\"$VERSION\""; footer


####################
# Script functions #
####################


# Interactive mode

im() { tty -s; }


# Print the usage.

usage () {
	cat <<EOT

$(_ 'SliTaz package manager - Version: %s' $(colorize 34 $VERSION))

$(boldify "$(_ 'Usage:')")
  $(_ 'tazpkg [command] [package|dir|pattern|list|cat|--opt] [dir|--opt]')

$(boldify "$(_ 'SHell:')") tazpkg shell

$(boldify "$(_ 'Commands:')")
$(optlist "\
     usage				$(_ 'Print this short usage')
-h   help				$(_ 'Show help on the TazPkg commands')
-a   activity			$(_ 'Show TazPkg activity log')
-cc  clean-cache		$(_ 'Clean all packages downloaded in cache directory')
     shell				$(_ 'Run interactive TazPkg shell')

-l   list				$(_ 'List installed packages on the system')
-lm  list-mirror		$(_ 'List all available packages on the mirror')
     list-config		$(_ 'List the configuration files')

-s   search				$(_ 'Search for a package by pattern or name')
-sp  search-pkgname		$(_ 'Search on mirror for package having a particular file')
-sf  search-file		$(_ 'Search for file in all installed packages files')

-g   get				$(_ 'Download a package into the current directory')
-i   install			$(_ 'Install a local package')
-gi  get-install		$(_ 'Download and install a package from the mirror')
     install-list		$(_ 'Install all packages from a list of packages')
     get-install-list	$(_ 'Download and install a list of packages from the mirror')
-r   remove				$(_ 'Remove the specified package and all installed files')
     reconfigure		$(_ 'Replay post install script from package')
     link				$(_ 'Link a package from another SliTaz installation')
     set-release		$(_ 'Change release and update packages')
     add-flavor			$(_ 'Install the flavor list of packages')
     install-flavor		$(_ 'Install the flavor list of packages and remove other ones')

     info				$(_ 'Print information about a package')
-d   desc				$(_ 'Print description of a package')
-lf  list-files			$(_ 'List the files installed with a package')
-b|u block|unblock		$(_ 'Block an installed package version or unblock it for upgrade')
     check				$(_ 'Verify consistency of installed packages')
     bugs				$(_ 'Show known bugs in packages')
     depends			$(_ 'Display dependencies tree')
     rdepends			$(_ 'Display reverse dependencies tree')
-e   extract			$(_ 'Extract a (*.tazpkg) package into a directory')
     pack				$(_ 'Pack an unpacked or prepared package tree')
     repack				$(_ 'Create a package archive from an installed package')
     repack-config		$(_ 'Create a package archive with configuration files')
     recompress			$(_ 'Rebuild a package with a better compression ratio')
     convert			$(_ 'Convert alien package to tazpkg')
     list-suggested		$(_ 'Print list of suggested packages')

     recharge			$(_ 'Recharge your packages.list from the mirror')
     up|help-up			$(_ 'Check packages %s to list and install latest upgrades' $CHECKSUM)
-sm  setup-mirror		$(_ 'Change the mirror URL configuration')
     setup-undigest		$(_ 'Update an undigest mirror')
     list-undigest		$(_ 'List undigest mirrors')
     add-undigest		$(_ 'Add an undigest mirror')
     remove-undigest	$(_ 'Remove an undigest mirror')
")
EOT
}


usage_up() {
	cat <<EOT
$(emsg "<b>$(_ 'Usage for command up:')</b>") tazpkg up [$(_ 'option')]

 * $(longline "$(_ 'Without options run in interactive mode and ask before install')")

$(boldify "$(_ 'Where options are:')")
$(optlist "\
-c  --check		$(_ 'Check only for available upgrades')
-r  --recharge	$(_ 'Force recharge of packages list and check')
-i  --install	$(_ 'Check for upgrades and install them all')
")

$(boldify "$(_ 'Example:')")
  tazpkg up --recharge --install
  tazpkg up -c -r
EOT
}


# Check if dir exists

check_dir() {
	if [ ! -d "$1" ]; then
		action 'Creating folder "%s"...' "$1"
		mkdir -p "$1"
		status
		return 1
	fi
}


# Check if the directories and files used by TazPkg exist.
# If not and user is root we create them.

check_base_dir() {
	if [ "$(id -u)" == '0' ]; then
		check_dir $1$CACHE_DIR
		check_dir $1$INSTALLED
		check_dir $1$SLITAZ_LOGS
		if [ ! -f "$1$PKGS_DB/mirror" ]; then
			echo "${DEFAULT_MIRROR%/}/" > $1$PKGS_DB/mirror
			[ -n "$1" ] && cp $PKGS_DB/packages.* $1$PKGS_DB/
		fi
	fi
}
check_base_dir


# Check for a package name on cmdline.

check_for_package_on_cmdline() {
	if [ -z "$PACKAGE" ]; then
		newline
		_ 'Please specify a package name on the command line.'
		newline
		exit 1
	fi
}


# Check if the package (*.tazpkg) exists before installing or extracting.

check_for_package_file() {
	if [ ! -f "$PACKAGE_FILE" ]; then
		newline
		_ 'Unable to find file "%s"' "$PACKAGE_FILE"
		newline
		exit 1
	fi
}


# Check for the receipt of an installed package.

check_for_receipt() {
	if [ ! -f "$1$INSTALLED/$PACKAGE/receipt" ]; then
		newline
		_ 'Unable to find the receipt "%s"' "$1$INSTALLED/$PACKAGE/receipt"
		newline
		exit 1
	fi
}


# Get repositories priority using $PKGS_DB/priority.
# In this file undigest repos are called by their names and main mirror
# by 'main'. Sort order: priority

look_for_priority() {
	[ -s "$PKGS_DB/priority" ] && priority=$(cat $PKGS_DB/priority)

	for rep in main $(ls $PKGS_DB/undigest 2>/dev/null); do
		if [ ! -s "$PKGS_DB/priority" ] || ! grep -q ^$rep$ $PKGS_DB/priority; then
			priority=$(echo -e "$priority\n$rep")
		fi
	done
	priority=$(echo "$priority" | sed '/^$/d' | \
		while read line; do
		case $line in
			(main) echo $PKGS_DB;;
			(*)    echo $PKGS_DB/undigest/$line;;
		esac
	done)
}


# Get package name in a directory

package_fullname_in_dir() {
	[ ! -f "$1/receipt" ] && return
	EXTRAVERSION=''
	. $1/receipt
	echo "$PACKAGE-$VERSION$EXTRAVERSION"
}


# Get package name that is already installed.

get_installed_package_pathname() {
	for i in $2$INSTALLED/${1%%-*}*; do
		[ ! -d $i ] && continue
		if [ "$1" == "$(package_fullname_in_dir $i)" ]; then
			echo "$i"
			return
		fi
	done
}


# Check if a package is already installed.

check_for_installed_package() {
	if [ -n "$(get_installed_package_pathname "$PACKAGE" "$1")" ]; then
		newline
		_ '"%s" package is already installed.' "$(colorize 34 "$PACKAGE")"
		longline "$(_ 'You can use the --forced option to force installation.')"
		newline
		exit 0
	fi
}


# Check for packages.list to download and install packages.

check_for_packages_list() {
	list_path="$PKGS_DB/packages.list"
	if [ ! -f "$list_path" ]; then
		if [ $(id -u) == 0 ]; then
			tazpkg recharge
		else
			newline
			_ 'Unable to find the list "%s"' $list_path
			_ \
"You must probably run 'tazpkg recharge' as root to get the latest list of
packages available on the mirror."
			newline
			exit 0
		fi
	fi
}


# Check for installed.info - local file with format of packages.info
# "installed.info" is absent on not clean installs; check it and re-generate if needed.

check_for_installed_info() {
	info_path="$ROOT$PKGS_DB/installed.info"
	if [ ! -f "$info_path" ]; then
		if [ "$(id -u)" == '0' ]; then
			_ 'File "%s" generated. Please wait...' 'installed.info'
			for pkg in $ROOT$PKGS_DB/installed/*/receipt; do
				unset_receipt
				. $pkg
				SIZES=$(echo $PACKED_SIZE $UNPACKED_SIZE | sed 's|\.0||g')
				DEPENDS=$(echo $DEPENDS) # remove newlines from some receipts
				MD5="$(fgrep " $PACKAGE-$VERSION$EXTRAVERSION.tazpkg" \
					$ROOT$PKGS_DB/installed.md5 | awk '{print $1}')"
				cat >> $info_path << EOT
$PACKAGE	$VERSION$EXTRAVERSION	$CATEGORY	$SHORT_DESC	$WEB_SITE	$TAGS	$SIZES	$DEPENDS	$MD5
EOT
			done
		else
			_ 'Unable to find file "%s"' installed.info
			_ 'Please run tazpkg as root.'
			exit 1
		fi
	fi

	# Check for md5 field (#9) in the installed.info
	if [ -n "$(awk -F$'\t' 'BEGIN{ n = "" } { if(NF != 9){ n = "o"; } } END{ print n }' $info_path)" ]; then
		_n 'File "%s" generated. Please wait...' 'installed.info.new'
		awk -F$'\t' -vm="$ROOT$PKGS_DB/installed.md5" 'BEGIN{OFS="\t"}
		{
			if (NF != 9) {
				pkg = $1 "-" $2 ".tazpkg";
				"fgrep " pkg " " m " | cut -c-32" | getline $9;
				$9 = ($9 == "") ? "00000000000000000000000000000000" : $9;
			}
			print;
		}' $info_path > $info_path.new
		mv -f $info_path.new $info_path
		status
	fi
}


get_cache_dir() {
	echo $rep > $tmp/rep
	if [ "$rep" == "$PKGS_DB" ]; then
		CACHE_DIR="$SAVE_CACHE_DIR/$SLITAZ_RELEASE/packages"
	elif [ "${rep%-incoming}" == "$rep" ]; then
		CACHE_DIR="$SAVE_CACHE_DIR/${rep##*/}/packages"
	else
		rep="${rep%-incoming}"
		CACHE_DIR="$SAVE_CACHE_DIR/${rep##*/}/packages-incoming"
	fi
	[ ! -d "$CACHE_DIR" ] && mkdir -p $CACHE_DIR
	echo $CACHE_DIR > $tmp/cachedir
}


# get an already installed package from packages.equiv

equivalent_pkg() {
	for i in $(grep -hs "^$1=" $PKGS_DB/packages.equiv \
		   $PKGS_DB/undigest/*/packages.equiv | sed "s/^$1=//"); do
		if echo $i | fgrep -q : ; then
			# format 'alternative:newname'
			# if alternative is installed then substitute newname
			if [ -f "$2$INSTALLED/${i%:*}/receipt" ]; then
				# substitute package dependency
				echo "${i#*:}"
				return
			fi
		else
			# if alternative is installed then nothing to install
			if [ -f "$2$INSTALLED/$i/receipt" ]; then
				# substitute installed package
				echo "$i"
				return
			fi
		fi
	done
	# if not found in packages.equiv then no substitution
	echo "$1"
}


# get a virtual package from packages.equiv

virtual_pkg() {
	for i in $(for rep in $priority; do
			grep -hs "^$1=" $rep/packages.equiv
		done | sed "s/^$1=//"); do
		if echo $i | fgrep -q : ; then
			# format 'alternative:newname'
			# if alternative is installed then substitute newname
			if [ -f "$2$INSTALLED/${i%:*}/receipt" ]; then
				# substitute package dependency
				echo "${i#*:}"
				return
			fi
		else
			# unconditional substitution
			echo "$i"
			return
		fi
	done
}


# Get package filename available on the mirror

get_package_filename() {
	# input: "<package_name>" or "<package_name>-<version>" (ex. "nano" or "nano-2.4.0")
	local pkg equiv
	for rep in $priority; do
		pkg=$(awk -F$'\t' -vp="$1" 'p==$1||p==$1"-"$2{print $1"-"$2}' $rep/packages.info)

		if [ -n "$pkg" ]; then
			get_cache_dir; break
		fi
	done
	if [ -z "$pkg" ]; then
		# Check for virtual package
		equiv=$(virtual_pkg $1)
		if [ "$equiv" != "$1" ]; then
			PACKAGE="$equiv"
			get_package_filename "$PACKAGE"
			return
		fi
	fi
	echo "$pkg"
}


# Check for a package in packages DB. Used by get and get-install to grep
# package basename.

check_for_package_in_list() {
	local filename check_only
	check_only="$1"
	filename="$(get_package_filename "$PACKAGE")"
	if [ -n "$filename" ]; then
		PACKAGE="$filename"
		CACHE_DIR="$(cat $tmp/cachedir)"
		rep="$(cat $tmp/rep)"
		rm -f $tmp/rep $tmp/cachedir
	else
		newline
		_ 'Unable to find package "%s" in the mirrored packages list.' "$PACKAGE"
		newline
		[ -n "$check_only" ] && return 1
		exit 0
	fi
}


# Log this activity
# (there log_pkg because we have log() in libtaz.sh)

log_pkg() {
	local extra

	[ "$1" == 'Installed' ] && \
	extra=" - $(fgrep "$PACKAGE-$VERSION" $PKGS_DB/installed.$SUM | awk '{ print $1 }')"

	[ -e "$LOG" ] || touch $LOG

	[ -w "$LOG" ] &&
	echo "$(date +'%F %T') - $1 - $PACKAGE ($VERSION$EXTRAVERSION)$extra" >> $LOG
}


# Download a get-package script from this mirror

download_get_script() {
	local p i
	for p in $priority ; do
		for i in $(cat $p/mirror) ; do
			case "$i" in
				http://*|https://*|ftp://*)
					busybox wget -q -T 30 -U $UA -O $2 \
						${i%packages/*}packages/get/$1 && return 0 ;;
			esac
		done
	done
	return 1
}


# Download a file from this mirror

download_from() {
	# input: "<mirror_url>+" "<package_name>-<version>.tazpkg"
	local i
	for i in $1; do
		case "$i" in
			# Mirror URL can have a trailing slash or not.
			http://* | https://* | ftp://*)
				busybox wget -c -q -T 30 -U $UA ${i%/}/$2 2>/dev/null && break ;;
			*)
				ln -sf ${i%/}/$2 . && break ;;
		esac
	done
}


# Download a file trying all mirrors

download() {
	# input: <package_name>-<version>.tazpkg
	local i
	case "$1" in
		*.tazpkg)
			for i in $priority; do
				if [ -n "$(awk -F$'\t' -vp="$1" 'p==$1"-"$2".tazpkg"{print $1}' \
					$i/packages.info)" ]; then
					download_from "$(cat $i/mirror)" "$@" && return
				fi
			done
			;;
	esac

	for i in $(cat $(for rep in $priority; do echo $rep/mirror; done) 2>/dev/null); do
		download_from "$i" "$@" && break
	done
}


# Extract a package with cpio and gzip/lzma.

extract_package() {
	action 'Extracting package...'
	cpio -idm --quiet < "${PACKAGE_FILE##*/}" && rm -f "${PACKAGE_FILE##*/}"
	if [ -f fs.cpio.lzma ]; then
		unlzma < fs.cpio.lzma | cpio -idm --quiet && rm fs.cpio.lzma
	elif [ -f fs.cpio.gz ]; then
		zcat fs.cpio.gz | cpio -idm --quiet && rm fs.cpio.gz
	fi
	status
}


remove_with_path() {
	# Avoid dirname errors by checking for argument.
	[ -n "$1" ] || return

	local dir
	rm -f $1 2>/dev/null
	dir="$1"
	while [ "$dir" != "/" ]; do
		dir="$(dirname "$dir")"
		rmdir "$dir" 2>/dev/null || break
	done
}


grepesc() {
	sed 's/\[/\\[/g'
}


# Print short package description
print_short_description() {
	local short_desc=''
	for LC in $LANG ${LANG%_*}; do
		if [ -e "$PKGS_DB/packages-desc.$LC" ]; then
			short_desc=$(grep -e "^$1	" $PKGS_DB/packages-desc.$LC | cut -d'	' -f2)
		fi
	done
	[ -z "$short_desc" -a -s $PKGS_DB/packages.info ] &&
		short_desc="$(awk -F$'\t' -vp="$PACKAGE" '{if($1==p){print $4;exit}}' $PKGS_DB/packages.info)"
	longline "$short_desc"
}


# This function installs a package in the rootfs.

install_package() {
	ROOT=$1
	if [ -n "$ROOT" ]; then
		# Get absolute path
		ROOT=$(realpath $ROOT)
	fi
	{
		# Create package path early to avoid dependencies loop
		mkdir -p $TMP_DIR
		{ cd $TMP_DIR ; cpio --quiet -i receipt >/dev/null 2>&1; } < "$PACKAGE_FILE"
		. $TMP_DIR/receipt
		# FIXME: legacy?
		if grep -q ^pre_depends $TMP_DIR/receipt; then
			pre_depends $ROOT
		fi

		# Keep modifiers and file list on upgrade
		cp "$ROOT$INSTALLED/$PACKAGE/modifiers" \
		   "$ROOT$INSTALLED/$PACKAGE/files.list" $TMP_DIR 2>/dev/null
		rm -rf "$ROOT$INSTALLED/$PACKAGE" 2>/dev/null

		# Make the installed package data dir to store
		# the receipt and the files list.
		mkdir -p "$ROOT$INSTALLED/$PACKAGE"
		cp $TMP_DIR/modifiers  "$ROOT$INSTALLED/$PACKAGE" 2>/dev/null
		cp $TMP_DIR/files.list "$ROOT$INSTALLED/$PACKAGE" 2>/dev/null
		rm -rf $TMP_DIR 2> /dev/null
		sed -i "/ $(basename "$PACKAGE_FILE")$/d" $ROOT$PKGS_DB/installed.$SUM 2>/dev/null
		cd "$(dirname "$PACKAGE_FILE")"
		$CHECKSUM "$(basename "$PACKAGE_FILE")" >> $ROOT$PKGS_DB/installed.$SUM
	}

	# Resolve package deps.
	check_for_deps $ROOT
	if [ -n "$MISSING_PACKAGE" ]; then
		install_deps $ROOT
	fi
	mkdir -p $TMP_DIR
	[ -n "$INSTALL_LIST" ] && echo "$PACKAGE_FILE" >> $ROOT$PKGS_DB/$INSTALL_LIST-processed

	title 'Installation of package "%s"' "$PACKAGE"

	short_desc="$(print_short_description "$PACKAGE")"
	[ -n "$short_desc" ] && echo "$short_desc" && separator '-'

	action 'Copying package...'
	cp "$PACKAGE_FILE" "$TMP_DIR"
	status

	cd "$TMP_DIR"
	extract_package
	SELF_INSTALL='0'
	EXTRAVERSION=''
	CONFIG_FILES=''

	# Include temporary receipt to get the right variables.
	. $PWD/receipt
	cd $ROOT$INSTALLED

	# FIXME: legacy?
	if [ $SELF_INSTALL -ne 0 -a -n "$ROOT" ]; then
		action "Checking post install dependencies..."
		[ -f "$INSTALLED/$PACKAGE/receipt" ]
		if ! status; then
			_ 'Please run "%s" in / and retry.' "tazpkg install $PACKAGE_FILE"
			rm -rf $TMP_DIR
			exit 1
		fi
	fi

	# Get files to remove if upgrading
	if [ -f "$PACKAGE/files.list" ]; then
		while read file; do
			grep -q "^$(echo $file | grepesc)$" $TMP_DIR/files.list && continue
			for i in $(cat "$PACKAGE/modifiers" 2>/dev/null ;
			    fgrep -sl "$PACKAGE" */modifiers | cut -d/ -f1 ); do
				grep -qs "^$(echo $file | grepesc)$" $i/files.list && continue 2
			done
			echo $file
		done < "$PACKAGE/files.list" > $TMP_DIR/files2remove.list
	fi

	# Remember modified packages
	{
		check=false
		for i in $(fgrep -v [ $TMP_DIR/files.list); do
			[ -e "$ROOT$i" ] || continue
			[ -d "$ROOT$i" ] && continue
			echo "- $i"
			check=true
		done ;
		$check && \
		for i in *; do
			[ "$i" == "$PACKAGE" ] && continue
			[ -s $i/files.list ] || continue
			awk "{ printf \"$i %s\\n\",\$1 }" < $i/files.list
		done;
	} | awk '
{
	if ($1 == "-" || file[$2] != "") {
		file[$2] = file[$2] " " $1
		if ($1 != "-") {
			if (pkg[$1] == "") all = all " " $1
			pkg[$1] = pkg[$1] " " $2
		}
	}
}
END {
	for (i = split(all, p, " "); i > 0; i--)
		for (j = split(pkg[p[i]], f, " "); j > 0; j--)
			printf "%s %s\n",p[i],f[j];
}
		' | while read dir file; do
		if grep -qs ^$dir$ "$PACKAGE/modifiers"; then
			# Do not overload an overloaded file !
			rm $TMP_DIR$file 2>/dev/null
			continue
		fi
		grep -qs "^$PACKAGE$" $dir/modifiers && continue
		if [ -s "$dir/volatile.cpio.gz" ]; then
			# We can modify backed up files without notice
			zcat $dir/volatile.cpio.gz | cpio -t --quiet | \
				grep -q "^${file#/}$" && continue
		fi
		echo "$PACKAGE" >> $dir/modifiers
	done

	cd $TMP_DIR
	cp receipt files.list "$ROOT$INSTALLED/$PACKAGE"

	# Copy the description if found.
	if [ -f "description.txt" ]; then
		cp description.txt "$ROOT$INSTALLED/$PACKAGE"
	fi

	# Copy the md5sum if found.
	if [ -f "$CHECKSUM" ]; then
		cp $CHECKSUM "$ROOT$INSTALLED/$PACKAGE"
	fi

	# Pre install commands.
	if grep -q ^pre_install "$ROOT$INSTALLED/$PACKAGE/receipt"; then
		pre_install $ROOT
	fi

	if [ -n "$CONFIG_FILES" ]; then
		# save 'official' configuration files
		action 'Saving configuration files...'
		for i in $CONFIG_FILES; do
			{ cd fs ; find ${i#/} -type f 2> /dev/null; cd ..; }
		done | { cd fs ; cpio -o -H newc --quiet | gzip -9; cd ..; } > \
			"$ROOT$INSTALLED/$PACKAGE/volatile.cpio.gz"

		if [ -z "$newconf" ]; then
			# keep user configuration files
			for i in $CONFIG_FILES; do
				{ cd fs ; find ${i#/} -type f 2> /dev/null; cd ..; }
			done | while read i; do
				[ -e $ROOT/$i ] || continue
				cp -a $ROOT/$i fs/$i
			done
		fi
		status
	fi

	action 'Installing package...'
	[ "$(busybox ls fs/* 2>/dev/null)" ] && cp -af fs/* $ROOT/
	status

	if [ -s files2remove.list ]; then
		action 'Removing old package...'
		while read file; do
			remove_with_path $ROOT$file
		done < files2remove.list
		true
		status
	fi

	# Remove the temporary random directory.
	action "Removing all tmp files..."
	cd ..; rm -rf $TMP_DIR
	status

	# Post install commands.
	if grep -q ^post_install "$ROOT$INSTALLED/$PACKAGE/receipt"; then
		action "Execute post-install commands..."
		post_install $ROOT
		status
	fi

	# Update-desktop-database if needed.
	if [ "$(fgrep .desktop "$ROOT$INSTALLED/$PACKAGE/files.list" | fgrep /usr/share/applications/)" ]; then
		updatedesktopdb=yes
	fi

	# Update-mime-database if needed.
	if [ "$(fgrep /usr/share/mime "$ROOT$INSTALLED/$PACKAGE/files.list")" ]; then
		updatemimedb=yes
	fi

	# Update-icon-database
	if [ "$(fgrep /usr/share/icon/hicolor "$ROOT$INSTALLED/$PACKAGE/files.list")" ]; then
		updateicondb=yes
	fi

	# Compile glib schemas if needed.
	if [ "$(fgrep /usr/share/glib-2.0/schemas "$ROOT$INSTALLED/$PACKAGE/files.list")" ]; then
		compile_schemas=yes
	fi

	# Update depmod list
	if [ "$(fgrep /lib/modules "$ROOT$INSTALLED/$PACKAGE/files.list")" ]; then
		updatedepmod=yes
	fi

	# Update installed.info
	check_for_installed_info
	SIZES=$(echo $PACKED_SIZE $UNPACKED_SIZE | sed 's|\.0||g')
	DEPENDS=$(echo $DEPENDS) # remove newlines from some receipts
	PKG_SUM="$(fgrep "$(basename "$PACKAGE_FILE")" "$ROOT$PKGS_DB/installed.$SUM" | cut -d' ' -f1)"
	II=$ROOT$PKGS_DB/installed.info
	sed -i "/^$PACKAGE	/d" $II # remove old entry
	cat >> $II <<EOT
$PACKAGE	$VERSION$EXTRAVERSION	$CATEGORY	$SHORT_DESC	$WEB_SITE	$TAGS	$SIZES	$DEPENDS	$PKG_SUM
EOT
	#awk -F$'\t' -vp="$PACKAGE" '$1==p' $ROOT$PKGS_DB/packages.info > $II
	TEMP_FILE=$(mktemp)
	sort $II > $TEMP_FILE; mv -f $TEMP_FILE $II; chmod a+r $II; unset II

	cd "$TOP_DIR"
	footer "$(_ 'Package "%s" (%s) is installed.' "$PACKAGE" "$VERSION$EXTRAVERSION")"

	# Log this activity
	[ -n "$ROOT" ] || log_pkg Installed

	# Remove package from upgrade list
	[ -s $UP_LIST ] && sed -i "/^$PACKAGE\$/d" $UP_LIST
}


# This function may be called by a get script.

abort_package() {
	cd $CUR_DIR
	rm -rf $TMP_DIR
	echo "${1:-Abort $PACKAGE.}"
	exit 1
}


# This function installs a package from a get script in the rootfs.

install_package_from_get_script() {
	SCRIPT="$1"
	ROOT="$2"
	[ -d "$ROOT$INSTALLED/$PACKAGE" ] && exit 1

	grep -q no-check-certificate $SCRIPT &&
		[ ! -d "$INSTALLED/wget" ] && tazpkg get-install wget

	mkdir -p $TMP_DIR && cd $TMP_DIR
	saved="$PACKAGE"
	unset_receipt
	PACKAGE="$saved"

	set -e
	. $SCRIPT
	set +e
	[ -d "$PACKAGE-$VERSION" ] || cd $TMP_DIR
	[ -d "$PACKAGE-$VERSION" ] || abort_package \
		"$(_ 'Could not download "%s" from "%s". Exiting.' "${TARBALL:-$PACKAGE}" "${WGET_URL:-$WEB_SITE}")"

	if [ ! -s "$PACKAGE-$VERSION/receipt" ]; then
		cat > "$PACKAGE-$VERSION/receipt" <<EOT
# SliTaz package receipt.

PACKAGE="$PACKAGE"
VERSION="${VERSION:-unknown}"
CATEGORY="${CATEGORY:-non-free}"
WEB_SITE="$WEB_SITE"
SHORT_DESC="${SHORT_DESC:-$PACKAGE}"
MAINTAINER="${MAINTAINER:-nobody@slitaz.org}"
EOT
		for i in LICENSE TARBALL WGET_URL CONFIG_FILES SUGGESTED \
			 PROVIDE DEPENDS HOST_ARCH TAGS EXTRA_SOURCE_FILES ; do
			eval "[ -n \"\$$i\" ] && echo \"$i=\\\"\$$i\\\"\""
		done >> "$PACKAGE-$VERSION/receipt"
	fi

	DEPENDS="$(unset DEPENDS; . "$PACKAGE-$VERSION/receipt"; echo $DEPENDS)"
	for i in $(find_depends "$PACKAGE-$VERSION/fs"); do
		case " $DEPENDS " in
			*\ $i\ *) continue;;
		esac
		grep -q '^DEPENDS="'         "$PACKAGE-$VERSION/receipt" ||
			echo 'DEPENDS=""' >>     "$PACKAGE-$VERSION/receipt"
		sed -i "s/^DEPENDS=\"/&$i /" "$PACKAGE-$VERSION/receipt"
	done

	TAZPKG_PACK=gzip
	tazpkg pack "$PACKAGE-$VERSION"

	# Clean to save RAM memory before installation
	rm -rf "$PACKAGE-$VERSION"

	if [ "$3" == '--get' ]; then
		mv "$PACKAGE-$VERSION.tazpkg" "$TOP_DIR"
	else
		# Install pseudo package
		tazpkg install "$PACKAGE-$VERSION.tazpkg" --root=$ROOT
		mv "$PACKAGE-$VERSION.tazpkg" $CACHE_DIR
	fi

	# Clean
	cd "$TOP_DIR"
	rm -rf $TMP_DIR
}


# Check for loop in deps tree.

check_for_deps_loop() {
	local list pkg="$1" deps
	shift
	[ -n "$1" ] || return
	list=''

	# Filter out already processed deps
	for i in $@; do
		case " $ALL_DEPS" in
			*\ $i\ *) ;;
			*) list="$list $i";;
		esac
	done
	ALL_DEPS="$ALL_DEPS$list "
	for i in $list; do
		[ -f $i/receipt ] || continue
		deps="$(DEPENDS=""; . $i/receipt; echo $DEPENDS)"
		case " $deps " in
			*\ $pkg\ *)
				print_pkgname
				echo -e "$MSG  $i"; MSG='';;
			*)
				check_for_deps_loop $pkg $deps;;
		esac
	done
}


# Check for missing deps listed in a receipt packages.

check_for_deps() {
	local saved;
	saved="$PACKAGE"
	mkdir -p $TMP_DIR
	{ cd $TMP_DIR ; cpio --quiet -i receipt >/dev/null 2>&1; } < "$PACKAGE_FILE"
	. $TMP_DIR/receipt
	PACKAGE="$saved"
	rm -rf $TMP_DIR

	num=0
	for pkgorg in $DEPENDS; do
		i=$(equivalent_pkg $pkgorg $1)
		if [ ! -d "$1$INSTALLED/$i" ]; then
			MISSING_PACKAGE=$i
			num=$(($num+1))
		elif [ ! -f "$1$INSTALLED/$i/receipt" ]; then
			_ 'WARNING! Dependency loop between "%s" and "%s".' "$PACKAGE" "$i"
		fi
	done

	if [ -n "$MISSING_PACKAGE" ]; then
		title "$(_ 'Tracking dependencies for package "%s"' "$PACKAGE")"
		for pkgorg in $DEPENDS; do
			i=$(equivalent_pkg $pkgorg $1)
			if [ ! -d "$1$INSTALLED/$i" ]; then
				MISSING_PACKAGE="$i"
				_ 'Missing package "%s"' $MISSING_PACKAGE
			fi
		done
		footer "$(_p \
			'%s missing package to install.' \
			'%s missing packages to install.' $num \
			$num)"
	fi
}


# Install all missing deps. Auto install or ask user then install all missing
# deps from local dir, CD-ROM, media or from the mirror. In case we want to
# install packages from local, we need a packages.list to find the version.

install_deps() {
	local root=''
	[ -n "$1" ] && root="--root=$1"

	if [ "$AUTO_INSTALL_DEPS" == 'yes' ]; then
		answer=0
	else
		newline
		confirm "$(_ 'Install all missing dependencies? (y/N)')"
		answer=$?
		newline
	fi

	if [ "$answer" -eq 0 ] && [ -z "$nodeps" ]; then
		for pkgorg in $DEPENDS; do
			pkg=$(equivalent_pkg $pkgorg $1)
			if [ ! -d "$1$INSTALLED/$pkg" ]; then
				local list="$INSTALL_LIST"
				[ -n "$list" ] || list="$TOP_DIR/packages.list"
				# We can install packages from a local dir by greping
				# the TAZPKG_BASENAME in the local packages.list.
				found='0'
				if [ -f "$list" ]; then
					_ 'Checking if package "%s" exists in local list...' $pkg
					mkdir $TMP_DIR
					for i in $pkg-*.tazpkg; do
						[ -f $i ] || continue
						{ cd $TMP_DIR ; cpio --quiet -i receipt > /dev/null 2>&1; } < $i
						[ "$(. $TMP_DIR/receipt; echo "$PACKAGE")" == "$pkg" ] || continue
						if grep -q ^$(package_fullname_in_dir $TMP_DIR).tazpkg$ $list
						then
							found='1'
							tazpkg install $i $root --list=$list
							break
						fi
					done
					rm -rf $TMP_DIR
				fi
				# Install deps from the mirror.
				if [ $found -eq 0 ]; then
					if [ ! -f "$PKGS_DB/packages.list" ]; then
						tazpkg recharge
					fi
					tazpkg get-install $pkg $root
				fi
			fi
		done
	else
		newline
		_ 'Leaving dependencies for package "%s" unresolved.' "$PACKAGE"
		_ 'The package is installed but will probably not work.'
		newline
	fi
}


# Search pattern in installed packages.

search_in_installed_packages() {
	_ 'Installed packages'
	separator '-'
	num='0'
	for pkg in $(ls -1 $INSTALLED | grep -i "$PATTERN"); do
		EXTRAVERSION=''
		[ -f $INSTALLED/$pkg/receipt ] || continue
		. $INSTALLED/$pkg/receipt
		emsg "$PACKAGE<i 24> $VERSION$EXTRAVERSION<i 42> $(_n $CATEGORY)"
		num=$(($num+1))
	done

	footer "$(_p \
		'%s installed package found for "%s"' \
		'%s installed packages found for "%s"' $num \
		$num "$PATTERN")"
}


# Search in packages.list for available pkgs.

search_in_packages_list() {
	_ 'Available packages'; separator '-'
	num='0'
	TMPLIST="$(mktemp)"
	BPATTERN="$(emsg "<b>$PATTERN</b>")"

	for i in $PKGS_DB/packages.info $PKGS_DB/undigest/*/packages.info; do
		[ -e "$i" ] && awk -F$'\t' -vpattern="$PATTERN" -vbpattern="$BPATTERN" \
		-vt="$TMPLIST" '
		BEGIN { IGNORECASE = 1 }
		index($1 "-" $2, pattern) {
			pv = $1 "-" $2; gsub(pattern, bpattern, pv); print pv;
			printf "1" >> t
		}' $i
	done

	for i in $PKGS_DB/extra.list $PKGS_DB/undigest/*/extra.list; do
		[ -e "$i" ] && awk -F'|' -vpattern="$PATTERN" -vbpattern="$BPATTERN" \
		-vt="$TMPLIST" '
		BEGIN { IGNORECASE = 1 }
		index($1 "-" $5, pattern) {
			if ($5) pv = $1 "-" $5; else pv = $1;
			gsub(pattern, bpattern, pv); print pv " (extra)";
			printf "1" >> t
		}' $i
	done

	if [ ! -f "$PKGS_DB/packages.info" ]; then
		newline
		longline "$(_ \
"No \"%s\" found to check for mirrored packages. For more results, please run \
\"%s\" once as root before searching." 'packages.info' 'tazpkg recharge')"
		newline
	fi

	num="$(wc -m < $TMPLIST)"; rm $TMPLIST
	footer "$(_p \
		'%s available package found for "%s"' \
		'%s available packages found for "%s"' $num \
		$num $PATTERN)"
}


# search --mirror: Search in packages.txt for available pkgs and give more
# info than --list or default.

search_in_packages_txt() {
	_ 'Matching packages name with version and desc'
	separator
	num='0'
	for i in \
		$PKGS_DB/packages.txt \
		$PKGS_DB/undigest/*/packages.txt; do

		grep -is -A 2 "^$PATTERN" $i
		num=$(($num + $(grep -is "^$PATTERN" $i | wc -l)))
	done

	if [ ! -f "$PKGS_DB/packages.txt" ]; then
		newline
		longline "$(_ \
"No \"%s\" found to check for mirrored packages. For more results, please run \
\"%s\" once as root before searching." 'packages.txt' 'tazpkg recharge')"
		newline
	fi

	footer "$(_p \
		'%s available package found for "%s"' \
		'%s available packages found for "%s"' $num \
		$num $PATTERN)"
}


# Install package-list from a flavor

install_flavor() {
	check_root $@

	# Get repositories priority list.
	look_for_priority

	FLAVOR="$1"
	mkdir -p $TMP_DIR
	[ -f $FLAVOR.flavor ] && cp $FLAVOR.flavor $TMP_DIR
	cd $TMP_DIR
	if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
		zcat < $FLAVOR.flavor | cpio --quiet -i >/dev/null

		while read file; do
			for pkg in $(ls -d $INSTALLED/${file%%-*}*); do
				[ -f $pkg/receipt ] || continue
				EXTRAVERSION=''
				. $pkg/receipt
				[ "$PACKAGE-$VERSION$EXTRAVERSION" == "$file" ] && break
			done
			[ "$PACKAGE-$VERSION$EXTRAVERSION" == "$file" ] && continue
			cd $CACHE_DIR
			download $file.tazpkg
			cd $TMP_DIR
			tazpkg install $CACHE_DIR/$file.tazpkg --forced
		done < $FLAVOR.pkglist

		[ -f $FLAVOR.nonfree ] && while read pkg; do
			[ -d $INSTALLED/$pkg ] || continue
			[ -d $INSTALLED/get-$pkg ] && tazpkg get-install get-$pkg
			get-$pkg
		done < $FLAVOR.nonfree

		# option "--purge"
		[ -n "$purge" ] && for pkg in $(ls $INSTALLED); do
			[ -f $INSTALLED/$pkg/receipt ] || continue
			EXTRAVERSION=''
			. $INSTALLED/$pkg/receipt
			grep -q "^$PACKAGE-$VERSION$EXTRAVERSION$" $FLAVOR.pkglist && continue
			grep -qs "^$PACKAGE$" $FLAVOR.nonfree && continue
			tazpkg remove "$PACKAGE"
		done
	else
		_ "Can't find flavor \"%s\". Abort." $FLAVOR
	fi
	cd "$TOP_DIR"
	rm -rf $TMP_DIR
}


# Update mirror URLs

setup_mirror() {
	# Backup old list.
	if [ -f "$1/mirror" ]; then
		cp -f $1/mirror $1/mirror.bak
	fi
	title 'Current mirror(s)'
	echo "  $(cat $1/mirror 2> /dev/null)"
	longline "$(_ \
"Please enter URL of the new mirror (http, ftp or local path). You must specify \
the complete address to the directory of the packages and packages.list file.")"
	newline

	_n 'New mirror(s) URL: '
	NEW_MIRROR_URL="$2"
	if [ -n "$NEW_MIRROR_URL" ]; then
		echo $NEW_MIRROR_URL
	else
		read NEW_MIRROR_URL
	fi

	if [ -z "$NEW_MIRROR_URL" ]; then
		_ 'Nothing has been changed.'
	else
		_ 'Setting mirror(s) to: "%s"' $NEW_MIRROR_URL
		rm -f $1/mirror
		for i in $NEW_MIRROR_URL; do
			echo "${i%/}/" >> $1/mirror
		done
	fi
	newline
}


# recursive dependencies scan

dep_scan() {
	for i in $1; do
		case " $ALL_DEPS " in
			*\ $i\ *) continue;;
		esac
		ALL_DEPS="$ALL_DEPS $i"
		[ -n "$2" ] && echo "$2$i ($(fgrep -A 3 $i $PKGS_DB/packages.txt | \
						tail -1 | sed 's/.*(\([^ ]*\).*/\1/'))"
		[ -f $i/receipt ] || continue
		DEPENDS=""
		. $i/receipt
		[ -n "$DEPENDS" ] && dep_scan "$DEPENDS" "$2  "
	done
}


# recursive reverse dependencies scan

rdep_scan() {
	SEARCH="$1"

	for i in * ; do
		DEPENDS=''
		. $i/receipt
		echo "$i $(echo $DEPENDS)"
	done | busybox awk -v search=$SEARCH '
function show_deps(deps, all_deps, pkg, space)
{
	if (all_deps[pkg] == 1) return
	all_deps[pkg] = 1
	if (space != "") printf "%s %s\n",space,pkg
	for (i = 1, n = split(deps[pkg], mydeps, " "); i <= n; i++) {
		show_deps(deps, all_deps, mydeps[i],"==" space)
	}
}

{
	all_deps[$1] = 0
	for (i = 2; i <= NF; i++)
		deps[$i] = deps[$i] " " $1
}

END {
	show_deps(deps, all_deps, search, "")
}
' | while read spc pkg; do
		echo -n $spc | sed 's/=/ /g'
		echo -n $pkg
		echo -n ' ('
		fgrep -A 3 $pkg $PKGS_DB/packages.txt | tail -1 | \
			sed 's/.*(\([^ ]*\).*/\1)/'
	done
}


update_desktop_database() {
	if [ -f "$1/usr/bin/update-desktop-database" ] && [ -n "$updatedesktopdb" ]; then
		chroot "$1/" /usr/bin/update-desktop-database /usr/share/applications 2>/dev/null
	fi
}


update_mime_database() {
	if [ -f "$1/usr/bin/update-mime-database" ] && [ -n "$updatemimedb" ]; then
		chroot "$1/" /usr/bin/update-mime-database /usr/share/mime
	fi
}


update_icon_database() {
	if [ -f "$1/usr/bin/gtk-update-icon-cache" ] && [ -n "$updateicondb" ]; then
		chroot "$1/" /usr/bin/gtk-update-icon-cache /usr/share/icons/hicolor
	fi
}


compile_glib_schemas() {
	if [ -f "$1/usr/bin/glib-compile-schemas" ] && [ -n "$compile_schemas" ]; then
		chroot "$1/" /usr/bin/glib-compile-schemas /usr/share/glib-2.0/schemas
	fi
}


update_kernel_modules() {
	if [ -f "$1/sbin/depmod" ] && [ -n "$updatedepmod" ]; then
		chroot "$1/" /sbin/depmod -a
	fi
}


# When recharging errors occur

recharging_failed() {
	# Restore database from bak files
	action 'Restoring database files...'
	[ -e 'ID'  -a ! -e 'ID.bak' ]  && rm ID
	[ -e 'IDs' -a ! -e 'IDs.bak' ] && rm IDs
	for file in $(ls $1/*.bak); do
		mv -f $file ${file%.bak}
	done
	status

	footer "$(colorize 31 "$(_ 'Recharging failed')")"
}


# Print package name if not printed yet
print_pkgname() {
	if [ "$PACKAGE" != "$PACKAGE_PRINTED" ]; then
		[ -n "$PACKAGE_PRINTED" ] && footer
		title 'Package %s' "$PACKAGE-$VERSION$EXTRAVERSION"
		PACKAGE_PRINTED="$PACKAGE"
	fi
}



###################
# TazPkg commands #
###################

case "$COMMAND" in
	list|-l)
		# List all installed packages or a specific category.
		shift
		check_for_installed_info

		case $1 in
			b|blocked)
				# Display the list of blocked packages.
				title 'Blocked packages'
				if [ -s "$BLOCKED" ];then
					cat $BLOCKED
					num=$(wc -l < $BLOCKED)
					footer "$(_p '%s package' '%s packages' "$num" \
						"$(colorize 31 $num)")"
				else
					_ 'No blocked packages found.'
				fi
				newline
				;;

			c|cat|categories)
				# Display the list of categories.
				title 'Packages categories'

				echo "$PKGS_CATEGORIES" | sed 's|[^a-z-]|\n|g; /^$/d' | \
				sed 's|\(.*\)|\1\t\1|' | translate_category | awk -F$'\t' '{
				if ($1==$2) print $1; else printf "%-14s %s\n", $1, $2}'

				num=$(echo -n "$PKGS_CATEGORIES" | wc -l)
				footer "$(_p '%s category' '%s categories' "$num" \
					"$(colorize 33 $num)")"
				;;

			'')
				# By default list all packages and versions.
				title 'List of all installed packages'
				awk -F$'\t' '{printf "%-34s %-17s %s\n", $1, $2, $3}' \
					$PKGS_DB/installed.info | translate_category

				num=$(wc -l < $PKGS_DB/installed.info)
				footer "$(_p '%s package installed.' '%s packages installed.' "$num" \
					"$(colorize 32 $num)")"
				;;

			*)
				# Check for an asked category.
				ASKED_CATEGORY_I18N="$@"
				ASKED_CATEGORY=$(reverse_translate_category "$ASKED_CATEGORY_I18N")
				title 'Installed packages of category "%s"' $ASKED_CATEGORY_I18N
				TMPLIST=$(mktemp)
				awk -F$'\t' -vcat="$ASKED_CATEGORY" \
					'{ if ($3 == cat) printf "%-34s %s\n", $1, $2; }' \
					$PKGS_DB/installed.info | tee $TMPLIST | translate_category

				num=$(wc -l < $TMPLIST); rm $TMPLIST
				footer "$(emsg $(_p \
					'%s package installed of category "%s".' \
					'%s packages installed of category "%s".' $num \
					"<c 32>$num</c>" "<c 34>$ASKED_CATEGORY_I18N</c>"))"
				;;
		esac ;;


	list-mirror|-lm)
		# List all available packages on the mirror. Option --diff displays
		# last mirrored packages diff (see recharge).
		check_for_packages_list
		case $2 in
			--diff)
				if [ -f "$PKGS_DB/packages.diff" ]; then
					title 'Mirrored packages diff'
					cat $PKGS_DB/packages.diff
					num=$(wc -l < $PKGS_DB/packages.diff)
					footer "$(_p \
						'%s new package listed on the mirror.' \
						'%s new packages listed on the mirror.' "$num" \
						"$(colorize 32 $num)")"
				else
					newline
					_ 'Unable to list anything, no packages.diff found.'
					_ 'Recharge your current list to create a first diff.'
					newline
				fi
				;;
			*)
				title 'List of available packages on the mirror'
				awk -F$'\t' '{
					split($7, s, " ");
					printf "%s\n%s\n%s\n%s (%s installed)\n\n", $1, $2, $4, s[1], s[2];
					}' $PKGS_DB/packages.info
				num=$(wc -l < $PKGS_DB/packages.info)
				footer "$(_p \
					'%s package in the last recharged list.' \
					'%s packages in the last recharged list.' "$num" \
					"$(colorize 32 $num)")"
				;;
		esac
		;;


	list-files|-lf)
		# List files installed with the package.
		check_for_package_on_cmdline
		if [ -d "$INSTALLED/$PACKAGE" ]; then
			# installed package
			title 'Installed files by "%s"' "$PACKAGE"
			sort < "$INSTALLED/$PACKAGE/files.list"
			num=$(wc -l < "$INSTALLED/$PACKAGE/files.list")
			footer "$(_p '%s file' '%s files' $num \
				"$(colorize 32 $num)")"
		elif [ -n "$(grep "^$PACKAGE"$'\t' $PKGS_DB/packages.info)" ]; then
			# available package
			title 'Installed files by "%s"' "$PACKAGE"
			TMPLIST=$(mktemp)
			lzcat $PKGS_DB/files.list.lzma | sed -n "/^$PACKAGE: / s|^[^:]*: ||p" | tee $TMPLIST
			num=$(wc -l < $TMPLIST); rm $TMPLIST
			footer "$(_p '%s file' '%s files' $num \
				"$(colorize 32 $num)")"
		else
			newline
			_ 'Package "%s" not available.' "$PACKAGE"
			newline
		fi
		;;


	info)
		# Information about package.
		check_for_package_on_cmdline
		check_for_receipt
		EXTRAVERSION=''
		. "$INSTALLED/$PACKAGE/receipt"
		im && title 'TazPkg information'
		# Display localized short description
		for LC in $LANG ${LANG%_*}; do
			PDL="$PKGS_DB/packages-desc.$LC"
			if [ -e "$PDL" ]; then
				LOCDESC=$(awk -F$'\t' -vp="$PACKAGE" '$1==p{print $2}' $PDL)
				[ -n "$LOCDESC" ] && SHORT_DESC="$LOCDESC"
			fi
		done
		SIZES=$(echo $PACKED_SIZE/$UNPACKED_SIZE | sed 's|\.0||g' | sed 's|^/$||')

		emsg "$(
		{
			_ 'Package    : %s' "$PACKAGE"
			_ 'Version    : %s' "$VERSION$EXTRAVERSION"
			_ 'Category   : %s' "$(_ $CATEGORY)"
itemize  "$(_ 'Short desc : %s' "$SHORT_DESC")"
			_ 'Maintainer : %s' "$MAINTAINER"
			_ 'License    : %s' "$LICENSE"
itemize  "$(_ 'Depends    : %s' "$DEPENDS")"
itemize  "$(_ 'Suggested  : %s' "$SUGGESTED")"
itemize  "$(_ 'Build deps : %s' "$BUILD_DEPENDS")"
itemize  "$(_ 'Wanted src : %s' "$WANTED")"
			_ 'Web site   : %s' "$WEB_SITE"
			_ 'Size       : %s' "$SIZES"
itemize  "$(_ 'Tags       : %s' "$TAGS")"
		} | sed '/: $/d; s|^\([^:]*\):|<b>\1:</b>|')"
		im && footer
		;;


	desc|-d)
		# Display package description
		unset desc

		# 1) Localized description
		for LC in $LANG ${LANG%_*}; do
			[ -e "$PKGS_DB/descriptions.$LC.txt" ] &&
			desc="$(awk -vRS='' -vFS='\n' -vOFS='\n' -vp="$PACKAGE" '
				$1 == p { $1 = ""; print $0; exit; }
				' "$PKGS_DB/descriptions.$LC.txt" | sed '1d')"
		done

		# 2) Installed description
		if [ -z "$desc" -a -s "$INSTALLED/$PACKAGE/description.txt" ]; then
			desc="$(cat "$INSTALLED/$PACKAGE/description.txt")"
		fi

		# 3) Mirrored description
		if [ -z "$desc" -a -s "$PKGS_DB/descriptions.txt" ]; then
			desc="$(awk -vRS='' -vFS='\n' -vOFS='\n' -vp="$PACKAGE" '
				$1 == p { $1 = ""; print $0; exit; }
				' "$PKGS_DB/descriptions.txt" | sed '1d')"
		fi

		# 4) Short description only in terminal
		if [ -z "$desc" ] && im; then
			desc="$(print_short_description "$PACKAGE")"
		fi

		if [ -n "$desc" ]; then
			# Title and footer only in terminal
			im && title 'Description of package "%s"' "$PACKAGE"
			echo "$desc"
			im && footer
		else
			im && _ 'Description absent.'
		fi
		;;


	activity|log|-a)
		# Show activity log
		[ -n "$nb" ] || nb='18'
		title 'TazPkg Activity'
		IFS=' '
		tail -n $nb $LOG | tac | \
		while read date hour none action none pkg vers none; do
			case $action in
				Installed)
					action=$(colorize 32 $action) ;;
				Removed)
					action=$(colorize 31 $action) ;;
				*)
					action=$(boldify $action) ;;
			esac
			date_locale="$(date -d "$date $hour" '+%x %X')"
			echo "$date_locale : $action $pkg $vers"
		done
		unset IFS
		footer ;;


	search|-s)
		# Search for a package by pattern or name.
		PATTERN="$2"
		if [ -z "$PATTERN" ]; then
			newline
			_ 'Please specify a pattern or package name to search for.'
			echo "$(_ 'Example:') 'tazpkg search paint'"
			newline
			exit 0
		fi
		title 'Search result for "%s"' "$PATTERN"
		# Default is to search in installed pkgs and the raw list.
		case "$3" in
			-i|--installed) search_in_installed_packages ;;
			-l|--list)      search_in_packages_list ;;
#buggy			-m|--mirror)    search_in_packages_txt ;;
			*)
				search_in_installed_packages
				search_in_packages_list ;;
		esac ;;


	search-file|-sf)
		# Search for a file by pattern or name in all files.list.
		if [ -z "$2" ]; then
			newline
			_ 'Please specify a pattern or file name to search for.'
			echo "$(_ 'Example:') 'tazpkg search-file libnss'"
			newline
			exit 0
		fi
		title 'Search result for file "%s"' "$2"
		TMPLIST=$(mktemp)

		if [ -n "$mirror" ]; then
			TMPDIR=$(mktemp -d)
			for i in $PKGS_DB/files.list.lzma $PKGS_DB/undigest/*/files.list.lzma; do
				[ -f $i ] || continue
				lzcat $i | awk -F: -vtmp="$TMPLIST" -vdir="$TMPDIR" \
					-vfile="$2" -vcfile="$(colorize 32 $2)" '
					BEGIN { efile = gensub("\+", "\\\+", "g", file); }
					index($2, file) {
						gsub(efile, cfile, $2);
						print $2 >> dir"/"$1;
						printf "1" >> tmp;
					}'
			done

			for pkg in $(cd $TMPDIR; ls); do
				newline
				emsg "<c 33>$(_ 'Package %s:' $pkg)</c>"
				cat $TMPDIR/$pkg
			done

			rm -r $TMPDIR

		else

			# Check all pkg files.list in search match which specify the package
			# name and the full path to the file(s).
			for pkg in $INSTALLED/*; do
				if grep -qs "$2" $pkg/files.list; then
					. $pkg/receipt
					newline
					emsg "<c 33>$(_ 'Package %s:' "$PACKAGE")</c>"
					awk -vtmp="$TMPLIST" -vfile="$2" -vcfile="$(colorize 32 $2)" '
						BEGIN { efile = gensub("\+", "\\\+", "g", file); }
						index($0, file) {
							gsub(efile, cfile);
							print " "$0;
							printf "1" >> tmp;
						}
					' $pkg/files.list
				fi
			done

		fi

		num=$(wc -m < $TMPLIST); rm $TMPLIST
		footer "$(_p '%s file' '%s files' "$num" \
			"$(colorize 32 $num)")"
		;;


	search-pkgname|-sp)
		# Search for a package name
		if [ -z "$2" ]; then
			newline
			_ 'Please specify a pattern or file name to search for.'
			echo "$(_ 'Example:') 'tazpkg search-pkgname libnss'"
			newline
			exit 0
		fi
		title 'Search result for package "%s"' "$2"

		# Search for a file on mirror and output only the package name
		TMPLIST=$(mktemp)
		for i in $PKGS_DB/files.list.lzma $PKGS_DB/undigest/*/files.list.lzma; do
				[ -f "$i" ] || continue
				lzcat $i | awk -F: -vT=$TMPLIST -vterm="$2" '
					BEGIN { P = "" }
					index($2, term) {
						if ($1 != P) {
							print $1;
							printf "1" >> T;
							P = $1
						}
					}'
		done
		match=$(wc -m < $TMPLIST)
		rm $TMPLIST

		footer "$(emsg "$(_p \
			'%s package' '%s packages' $match \
			"<c 32>$match</c>")")"
		;;


	install|-i)
		# Install .tazpkg packages.
		check_root $@
		check_for_package_on_cmdline
		check_for_package_file
		check_for_installed_info

		if [ -n "$root" ]; then
			ROOT="$root";
			check_base_dir "$root"
		fi

		[ -n "$list" ] && INSTALL_LIST="$list"

		if [ -n "$rootconfig" ]; then					# What about this parameter? Is it obsolete?
			if [ -n "$root" ]; then
				CACHE_DIR="$root/$CACHE_DIR"
				SAVE_CACHE_DIR="$CACHE_DIR"
				PKGS_DB="$root/$PKGS_DB"
			else
				echo "rootconfig needs --root= option used." >&2
				exit 1
			fi
		fi

		# Get repositories priority list.
		look_for_priority

		# Check if forced install.
		if [ -z "$forced" ]; then
			check_for_installed_package $ROOT
		fi
		install_package $ROOT
		update_desktop_database $ROOT
		update_mime_database $ROOT
		update_icon_database $ROOT
		compile_glib_schemas $ROOT
		;;


	install-list|get-install-list)
		# Install a set of packages from a list.
		check_root $@

		if [ -z "$2" ]; then
			newline
			longline "$(_ \
"Please change directory (cd) to the packages repository and specify the \
list of packages to install.")"
			echo "$(_ 'Example:') $(emsg '<b>tazpkg install-list</b> <c 33>packages.list</c>')"
			exit 0
		fi

		# Check if the packages list exist.
		if [ ! -f "$2" ]; then
			_ 'Unable to find list "%s"' "$2"
			exit 0
		fi

		LIST=$(cat $2)

		# Remember processed list
		export INSTALL_LIST="$2"

		# Set $COMMAND and install all packages.
		COMMAND=${1%-list}

		touch $2-processed

		# Upgrade tazpkg first. It may handle new features/formats...
		# then upgrade essential packages early
		for pkg in busybox-pam busybox gcc-lib-base glibc-base \
				slitaz-base-files tazpkg ; do
			pkg=$(egrep $pkg-[0-9] $INSTALL_LIST)
			[ -z "$pkg" ] && continue
			_ 'Adding implicit depends "%s"...' $pkg
			LIST="$pkg"$'\n'"$LIST"
		done

		for pkg in $LIST; do
			grep -qs ^$pkg$ $2-processed && continue
			[ -d "$root/var/lib/tazpkg/installed" ] && 
			tazpkg $COMMAND $pkg --list="$2" "$3" "$4" "$5"
		done
		rm -f $2-processed ;;


	add-flavor)
		# Install a set of packages from a flavor.
		install_flavor $2 ;;


	install-flavor)
		# Install a set of packages from a flavor and purge other ones.
		install_flavor $2 --purge ;;


	set-release)
		# Change current release and upgrade packages.
		RELEASE="$2"
		if [ -z "$RELEASE" ]; then
			newline
			_ 'Please specify the release you want on the command line.'
			echo "$(_ 'Example:') tazpkg set-release cooking"
			newline
			exit 0
		fi
		rm $PKGS_DB/mirror
		echo "$RELEASE" > /etc/slitaz-release
		tazpkg recharge && tazpkg upgrade

		# Install missing depends
		cd $INSTALLED
		for i in * ; do
			DEPENDS=''
			. $i/receipt
			for j in $DEPENDS ; do
				[ -d $j ] || tazpkg get-install $j
			done
		done ;;


	remove|-r)
		# Remove packages.
		check_root $@
		check_for_package_on_cmdline
		check_for_installed_info

		[ -n "$root" ] && ROOT="$root"

		if [ ! -f "$ROOT$INSTALLED/$PACKAGE/receipt" ]; then
			newline; _ 'Package "%s" is not installed.' "$PACKAGE"
			exit 0
		fi

		. "$ROOT$INSTALLED/$PACKAGE/receipt"

		# Info #1: dependent packages (to be processed later)
		ALTERED="$(awk -F$'\t' -vp=" $PACKAGE " '
			index(" " $8 " ", p) { printf "  %s\n", $1 }
			' $ROOT/$PKGS_DB/installed.info)"

		if [ -n "$ALTERED" ]; then
			_ 'The following packages depend on package "%s":' "$PACKAGE"
			echo "$ALTERED"
		fi

		# Info #2: changed packages (to be processed later)
		REFRESH=$(cd $ROOT$INSTALLED ; grep -sl "^$PACKAGE$" */modifiers)

		if [ -n "$REFRESH" ]; then
			_ 'The following packages have been modified by package "%s":' "$PACKAGE"
			for i in $REFRESH; do
				echo "  ${i%/modifiers}"
			done
		fi

		# Confirmation
		if im && [ -z "$auto" ]; then
			confirm "$(_ 'Remove package "%s" (%s)? (y/N)' "$PACKAGE" "$VERSION$EXTRAVERSION")"
			if [ "$?" -ne 0 ]; then
				newline; _ 'Uninstallation of package "%s" cancelled.' "$PACKAGE"
				exit 0
			fi
		fi
		# We are here: non-interactive mode, or --auto, or answer 'y'

		# Removing package
		title 'Removing package "%s"' "$PACKAGE"

		# [1/4] Pre-remove commands
		if grep -q ^pre_remove "$ROOT$INSTALLED/$PACKAGE/receipt"; then
			action "Execution of pre-remove commands..."
			pre_remove $ROOT
			status
		fi

		# [2/4] Removing files
		action "Removing all files installed..."
		if [ -f "$ROOT$INSTALLED/$PACKAGE/modifiers" ]; then
			for file in $(cat "$ROOT$INSTALLED/$PACKAGE/files.list"); do
				for mod in $(cat "$ROOT$INSTALLED/$PACKAGE/modifiers"); do
					[ -f "$ROOT$INSTALLED/$mod/files.list" ] && \
					[ $(grep "^$(echo $file | grepesc)$" $ROOT$INSTALLED/$mod/files.list | wc -l) -gt 1 ] && \
					continue 2
				done
				remove_with_path $ROOT$file
			done
		else
			for file in $(cat "$ROOT$INSTALLED/$PACKAGE/files.list"); do
				remove_with_path $ROOT$file
			done
		fi
		status

		# [3/4] Post-remove commands
		if grep -q ^post_remove "$ROOT$INSTALLED/$PACKAGE/receipt"; then
			action 'Execution of post-remove commands...'
			post_remove $ROOT
			status
		fi

		# [4/4] Remove package receipt and remove it from databases
		action 'Removing package receipt...'
		rm -rf "$ROOT$INSTALLED/$PACKAGE"
		sed -i "/ $PACKAGE-$VERSION$EXTRAVERSION.tazpkg$/d" $PKGS_DB/installed.$SUM
		sed -i "/^$PACKAGE	/d" $PKGS_DB/installed.info
		status

		footer "$(_ 'Package "%s" (%s) removed.' "$PACKAGE" "$VERSION$EXTRAVERSION")"

		# Log this activity
		log_pkg Removed

		# Stop if non-interactive mode and no --auto option
		if ! im && [ -z "$auto" ]; then exit 0; fi

		# Process dependent packages
		if [ -n "$ALTERED" ]; then
			if [ -n "$auto" ]; then
				answer=0
			else
				confirm "$(_ 'Remove packages depending on package "%s"? (y/N)' "$PACKAGE")"
				answer=$?
			fi
			if [ "$answer" -eq 0 ]; then
				for i in $ALTERED; do
					if [ -d "$ROOT$INSTALLED/$i" ]; then
						echo "tazpkg remove $i $ROOTOPTS"
					fi
				done
			fi
		fi

		# Process changed packages
		if [ -n "$REFRESH" ]; then
			if [ -n "$auto" ]; then
				answer=0
			else
				confirm "$(_ 'Reinstall packages modified by package "%s"? (y/N)' "$PACKAGE")"
				answer=$?
			fi
			if [ "$answer" -eq 0 ]; then
				for i in $REFRESH; do
					if [ "$(wc -l < $ROOT$INSTALLED/$i)" -gt 1 ]; then
						_ 'Check %s for reinstallation' "$INSTALLED/$i"
						continue
					fi
					rm -r $ROOT$INSTALLED/$i
					tazpkg get-install ${i%/modifiers} $ROOTOPTS --forced
				done
			fi
		fi

		;;


	extract|-e)
		# Extract .tazpkg cpio archive into a directory.
		check_for_package_on_cmdline
		check_for_package_file
		title 'Extracting package "%s"' "$PACKAGE"

		# If no directory destination is found on the cmdline
		# we create one in the current dir using the package name.
		if [ -n "$TARGET_DIR" ]; then
			DESTDIR="$TARGET_DIR/$PACKAGE"
		else
			DESTDIR="$PACKAGE"
		fi
		mkdir -p $DESTDIR

		action 'Copying original package...'
		cp "$PACKAGE_FILE" $DESTDIR
		status

		cd $DESTDIR
		extract_package
		[ -e "receipt" ] && \
			footer "$(_ 'Package "%s" is extracted to "%s"' "$PACKAGE" "$DESTDIR")"
		;;


	recompress)
		# Recompress .tazpkg cpio archive with lzma.
		check_for_package_on_cmdline
		check_for_package_file
		title 'Recompressing package "%s"' "$PACKAGE"
		mkdir -p $TMP_DIR

		action "Copying original package..."
		cp "$PACKAGE_FILE" $TMP_DIR
		status

		cd $TMP_DIR
		extract_package

		action "Recompressing the FS..."
		find fs | cpio -o -H newc --quiet | lzma e fs.cpio.lzma -si
		rm -rf fs
		status

		action "Creating new package..."
		find . -print | cpio -o -H newc --quiet > \
			"$TOP_DIR/$(basename "$PACKAGE_FILE").$$" && mv -f \
			"$TOP_DIR/$(basename "$PACKAGE_FILE").$$" \
			"$TOP_DIR/$(basename "$PACKAGE_FILE")"
		status

		cd "$TOP_DIR"
		rm -rf $TMP_DIR
		separator; newline ;;


	list-config)
		# List configuration files installed.
		if [ -n "$box" ]; then
			mkdir -p $TMP_DIR; cd $TMP_DIR
			FILES="$INSTALLED/*/volatile.cpio.gz"
			[ -n "$3" ] && FILES="$INSTALLED/$3/volatile.cpio.gz"
			for i in $FILES; do
				zcat $i | cpio -idm --quiet > /dev/null
				find * -type f 2>/dev/null | while read file; do
					if [ ! -e /$file ]; then
						echo -n "----------|----|----|$(_n 'File lost')"
					else
						echo -n "$(stat -c "%A|%U|%G|%s|" /$file)"
						cmp $file /$file > /dev/null 2>&1 || \
						echo -n "$(stat -c "%.16y" /$file)"
					fi
					echo "|/$file"
				done
				rm -rf *
			done
			cd "$TOP_DIR"
			rm -rf $TMP_DIR
		else
			im && title 'Configuration files'
			for i in $INSTALLED/*/volatile.cpio.gz; do
				[ -n "$2" -a "$i" != "$INSTALLED/$2/volatile.cpio.gz" ] && continue
				[ -f "$i" ] || continue
				zcat $i | cpio -t --quiet
			done | sed 's|^|/|' | sort
			im && footer
		fi ;;


	repack-config)
		check_root $@
		# Create SliTaz package archive from configuration files.
		mkdir -p $TMP_DIR; cd $TMP_DIR
		CONFIG_VERSION='1.0'
		mkdir config-$CONFIG_VERSION
		cd config-$CONFIG_VERSION
		for i in $INSTALLED/*/volatile.cpio.gz; do
			zcat $i | cpio -t --quiet
		done > files.list
		mkdir fs
		cd fs
		( cd / ; cpio -o -H newc --quiet ) < ../files.list | cpio -idm --quiet > /dev/null
		mkdir -p etc/tazlito
		for i in $INSTALLED/*/receipt; do
			EXTRAVERSION=''
			. $i
			echo "$PACKAGE-$VERSION$EXTRAVERSION"
		done > etc/tazlito/config-packages.list
		cd ..
		echo "etc/tazlito/config-packages.list" >> files.list
		pkg_date=$(date +"%x %X")
		cat > receipt <<EOT
# SliTaz package receipt.

PACKAGE="config"
VERSION="$CONFIG_VERSION"
CATEGORY="base-system"
SHORT_DESC="$(_n 'User configuration backup on date %s' $pkg_date)"
DEPENDS="$(ls $INSTALLED)"
EOT
		cd ..
		tazpkg pack config-$CONFIG_VERSION
		cp config-$CONFIG_VERSION.tazpkg "$TOP_DIR"
		cd "$TOP_DIR"
		rm -rf $TMP_DIR
		;;


	repack)
		# Create SliTaz package archive from an installed package.
		check_for_package_on_cmdline
		check_for_receipt
		EXTRAVERSION=''
		. "$INSTALLED/$PACKAGE/receipt"
		title 'Repacking "%s"' "$PACKAGE-$VERSION$EXTRAVERSION.tazpkg"

		if grep -qs ^NO_REPACK= "$INSTALLED/$PACKAGE/receipt"; then
			_ "Can't repack package \"%s\"" "$PACKAGE"
			exit 1
		fi

		if [ -s "$INSTALLED/$PACKAGE/modifiers" ]; then
			_ "Can't repack, \"%s\" files have been modified by:" "$PACKAGE"
			for i in $(cat "$INSTALLED/$PACKAGE/modifiers"); do
				echo "  $i"
			done
			exit 1
		fi

		MISSING=''
		while read i; do
			[ -e "$i" ] && continue
			[ -L "$i" ] || MISSING="$MISSING\n  $i"
		done < "$INSTALLED/$PACKAGE/files.list"
		if [ -n "$MISSING" ]; then
			_n "Can't repack, the following files are lost:"
			echo -e "$MISSING"
			exit 1
		fi

		mkdir -p $TMP_DIR; cd $TMP_DIR
		FILES="fs.cpio.lzma\n"
		for i in $(ls "$INSTALLED/$PACKAGE"); do
			case $i in
				volatile.cpio.gz|modifiers) ;;
				*) cp "$INSTALLED/$PACKAGE/$i" .; FILES="$FILES$i\n" ;;
			esac
		done

		ln -s / rootfs
		mkdir tmp
		sed 's/^/rootfs/' < files.list | cpio -o -H newc --quiet | \
			{ cd tmp ; cpio -idm --quiet >/dev/null; cd ..; }
		mv tmp/rootfs fs

		if [ -f  "$INSTALLED/$PACKAGE/volatile.cpio.gz" ]; then
			zcat "$INSTALLED/$PACKAGE/volatile.cpio.gz" | \
				{ cd fs; cpio -idm --quiet; cd ..; }
		fi

		if fgrep -q repack_cleanup "$INSTALLED/$PACKAGE/receipt"; then
			. "$INSTALLED/$PACKAGE/receipt"
			repack_cleanup fs
		fi

		if [ -f "$INSTALLED/$PACKAGE/$CHECKSUM" ]; then
			sed 's,  ,  fs,' < "$INSTALLED/$PACKAGE/$CHECKSUM" | \
			$CHECKSUM -s -c || {
				_ "Can't repack, %s error." "$CHECKSUM"
				cd "$TOP_DIR"
				rm -rf $TMP_DIR
				exit 1
			}
		fi

		find fs | cpio -o -H newc --quiet | lzma e fs.cpio.lzma -si
		echo -e "$FILES" | cpio -o -H newc --quiet > \
			"$TOP_DIR/$PACKAGE-$VERSION$EXTRAVERSION.tazpkg"
		cd "$TOP_DIR"
		\rm -R $TMP_DIR
		_ 'Package "%s" repacked successfully.' "$PACKAGE"
		_ 'Size: %s' "$(du -sh "$PACKAGE-$VERSION$EXTRAVERSION.tazpkg")"
		newline
		;;


	pack)
		# Create SliTaz package archive using cpio and lzma.
		# TODO: Cook also pack packages, we should share code in libpkg.sh
		check_for_package_on_cmdline
		cd "$PACKAGE"
		if [ ! -f 'receipt' ]; then
			_ 'Receipt is missing. Please read the documentation.'
			exit 0
		fi

		title 'Packing package "%s"' "$PACKAGE"
		# Create files.list with redirecting find outpout.

		action 'Creating the list of files...'
		cd fs
		find . -type f -print > ../files.list
		find . -type l -print >> ../files.list
		cd ..; sed -i s/'^.'/''/ files.list
		status

		action 'Creating %s of files...' "$CHECKSUM"
		while read file; do
			[ -L "fs$file" ] && continue
			[ -f "fs$file" ] || continue
			case "$file" in
				/lib/modules/*/modules.*|*.pyc) continue;;
			esac
			$CHECKSUM "fs$file" | sed 's/  fs/  /'
		done < files.list > $CHECKSUM
		status

		UNPACKED_SIZE=$(du -chs fs receipt files.list $CHECKSUM \
			description.txt 2>/dev/null | awk 'END { print $1 }')

		# Build cpio archives.
		action "Compressing the FS..."
		find fs | cpio -o -H newc --quiet | case "$TAZPKG_PACK" in
		gzip) gzip -9 > fs.cpio.gz ;;
		*) lzma e fs.cpio.lzma -si ;;
		esac
		rm -rf fs
		status

		PACKED_SIZE=$(du -chs fs.cpio.lzma receipt files.list \
			$CHECKSUM description.txt 2>/dev/null | awk 'END { print $1 }')

		action "Updating receipt sizes..."
		sed -i s/^PACKED_SIZE.*$// receipt
		sed -i s/^UNPACKED_SIZE.*$// receipt
		sed -i "s/^PACKAGE=/PACKED_SIZE=\"$PACKED_SIZE\"\nUNPACKED_SIZE=\"$UNPACKED_SIZE\"\nPACKAGE=/" receipt
		status

		action "Creating full cpio archive..."
		find . -print | cpio -o -H newc --quiet > "../$PACKAGE.tazpkg"
		status

		action "Restoring original package tree..."
		unlzma < fs.cpio.lzma | cpio -idm --quiet
		status

		rm fs.cpio.lzma && cd ..
		footer "$(_ 'Package "%s" compressed successfully.' "$PACKAGE")"
		_ 'Size: %s' "$(ls -lh "$PACKAGE.tazpkg" | awk '{print $5}')"
		;;


	recharge)
		# Recharge packages databases from a mirror.
		#
		# WARNING: The 'mirrors' file has all SliTaz mirrors but 'mirror'
		# must have only the chosen main mirror.
		#
		check_root $@

		# usage: tazpkg recharge [--root=path] [main|<repository>]

		ARG="$2"
		if [ -n "$root" ]; then
			PKGS_DB="$root$PKGS_DB"
			[ "${2#--}" != "$2" ] && ARG="$3"
		fi

		case "$ARG" in
			main) repo_to_recharge="$PKGS_DB";;
			'')   repo_to_recharge="$PKGS_DB $PKGS_DB/undigest/*";;
			*)    repo_to_recharge="$PKGS_DB/undigest/$ARG"
				if [ ! -d "$repo_to_recharge" ]; then
					_ "Repository \"%s\" doesn't exist." "$repo_to_recharge" >&2
					exit 1
				fi
				;;
		esac

		for path in $repo_to_recharge; do
			[ ! -f $path/mirror ] && continue	# skip
			cd $path
			mirror="$(cat mirror)"

			# Repository name
			if [ "$path" == "$PKGS_DB" ]; then
				repo_name='Main'
			else
				repo_name="$(_n 'Undigest %s' "$(basename "$path")")"
			fi

			title 'Recharging repository "%s"' "$repo_name"

			# Don't let ID be a symlink when using local repository.
			if [ -h ID  ]; then mv -f ID  ID.lnk;  cat ID.lnk  > ID;  rm ID.lnk;  fi
			if [ -h IDs ]; then mv -f IDs IDs.lnk; cat IDs.lnk > IDs; rm IDs.lnk; fi

			[ -f ID ]  && mv ID  ID.bak					# Compatibility with "old" ID
			[ -f IDs ] && mv IDs IDs.bak
			download_from "$mirror" IDs
			[ -e 'IDs' ] && awk '{print $1}' IDs > ID	# Compatibility with "old" ID

			# Check if recharging is needed
			if [ -f 'IDs' ] && cmp -s IDs IDs.bak; then
				action 'Checking...'; status			# "Fake" message
				footer "$(_ 'Repository "%s" is up to date.' "$repo_name")"
				rm IDs.bak ID.bak
				continue
			fi
			rm IDs.bak ID.bak 2>/dev/null

			[ -e 'IDs' ] && _ 'Database timestamp: %s' "$(date -d "@$(awk '{print $2}' IDs)" "+%x %R")"

			action 'Creating backup of the last packages list...'
			for i in packages.desc packages.$SUM packages.txt packages.list \
				packages.equiv files.list.lzma extra.list mirrors packages.info; do
				[ -f "$i" ] && mv -f $i $i.bak 2>/dev/null
			done
			status

			# Download and extract bundle: extra.list, mirrors, files-list.md5,
			#   packages.{info,desc,md5,txt,list,equiv}
			bundle='bundle.tar.lzma'
			action 'Getting "%s"...' $bundle
			download_from "$mirror" $bundle
			status
			if [ -f "$bundle" ]; then
				busybox tar -xaf $bundle; rm $bundle
			else
				recharging_failed $path; continue
			fi

			# Download files.list.lzma
			files_local='files.list.lzma'; files_remote='files-list.lzma'
			if [ -e "$files_local.bak" ]; then
				md5sum $files_local.bak | awk '{printf $1}' > files-list.md5.bak
				if cmp -s files-list.md5 files-list.md5.bak; then
					mv $files_local.bak $files_remote
				else
					action 'Getting "%s"...' $files_remote
					download_from "$mirror" $files_remote
					status
				fi
			else
				action 'Getting "%s"...' $files_remote
				download_from "$mirror" $files_remote
				status
			fi

			if [ ! -e "$files_remote" ]; then
				recharging_failed $path; continue
			fi
			mv -f $files_remote $files_local

			# Remove old database files (but packages.list.bak, extra.list.bak)
			for i in packages.desc packages.$SUM packages.txt packages.equiv \
				files.list.lzma mirrors packages.info files-list.md5; do
				[ -f "$i.bak" ] && rm $i.bak 2>/dev/null
			done

			footer "$(_ 'Last database is ready to use.')"

			# Check diff
			if [ -f 'packages.list.bak' ]; then
				diff -u packages.list.bak packages.list | grep ^+[a-z] > packages.diff
				rm packages.list.bak
				if [ -f 'extra.list.bak' ]; then
					if [ -f 'extra.list' ]; then
						awk -F'|' '{print $1 " (extra)"}' extra.list > extra.list1
						awk -F'|' '{print $1 " (extra)"}' extra.list.bak > extra.list1.bak
						diff -u extra.list1.bak extra.list1 | grep ^+[a-z] >> packages.diff
						rm extra.list.bak extra.list1 extra.list1.bak
					else
						mv extra.list.bak extra.list
					fi
				fi
				sed -i s/+// packages.diff

				new_pkgs=$(wc -l < packages.diff)
				if [ "$new_pkgs" -gt 0 ]; then
					title 'Mirrored packages diff'
					cat packages.diff
					footer "$(emsg "$(_p \
					'%s new package on the mirror.' \
					'%s new packages on the mirror.' $new_pkgs \
					"<c 32>$new_pkgs</c>")")"
				fi
			else
				longline "$(_ "Note that next time you recharge the \
list, a list of differences will be displayed to show new and upgradeable \
packages.")"
			fi
		done
		newline ;;


	help-up)
		# Options available for the command: up
		newline; usage_up; newline
		exit 1 ;;


	up|upgrade)
		check_root
		#
		# This is the new way to upgrade packages making 'upgrade' and
		# upgradeable out-of-date. This new way is much, much more faster!
		# Look into installed packages and get data from receipt, it is fast
		# and easy to handle vars after using only md5sum to compare packages
		#
		for opt in $@; do
			case "$opt" in
				--recharge|-r)	tazpkg recharge ;;
				--install|-i)	install="y" ;;
				--check|-c) 	install="n" ;;
			esac
		done
		time="$(date +%s)"

		look_for_priority
		for repo in $priority; do
			pkg_list="$repo/packages.list"
			mtime=$(find $pkg_list -mtime +7)
			if [ -n "$mtime" ]; then
				if [ "$repo" == "$PKGS_DB" ]; then
					repo_name='main'
				else
					repo_name="${repo##*/}"
				fi
				_ 'List "%s" is older than one week... Recharging.' $pkg_list
				tazpkg recharge $repo_name
			fi
		done

		emsg "<n>$(_ 'Package')<i 28> $(_ 'Version')<i 48> $(_ 'Status')<->"

		cd $INSTALLED
		echo -n > $UP_LIST
		blocked_count=0
		installed_sum="$PKGS_DB/installed.$SUM"

		for pkg in *; do
			[ ! -d $pkg ] && continue
			unset VERSION EXTRAVERSION
			. $pkg/receipt
			md5=$(fgrep "  $PACKAGE-$VERSION$EXTRAVERSION.tazpkg" \
				$installed_sum | awk '{print $1}')
			for repo in $priority; do
				pkg_desc="$repo/packages.desc"
				pkg_list="$repo/packages.list"
				pkg_sum="$repo/packages.$SUM"

				if ! fgrep -q "$md5  $PACKAGE-" $pkg_sum; then
					# Jump to next repository in priority if pkg doesn't exist
					# in this one.
					grep -q "^$PACKAGE-" $pkg_list || continue

					emsg -n "$PACKAGE<i 28> $VERSION"

					# Skip pkgs listed in $PKGS_DB/blocked-packages.list
					if $(grep -qs "^$PACKAGE" $BLOCKED); then
						blocked_count=$(($blocked_count + 1))
						emsg "<i 48><c 31> $(_ 'Blocked')</c>"
						break
					fi

					new=$(grep "^$PACKAGE |" $pkg_desc | awk '{print $3}')

					if [ "$VERSION" == "$new" ]; then
						emsg "<i 48><c 34> $(_ 'New build')</c>"
					else
						emsg "<i 48><c 32> $(_ 'New version %s' "$new")</c>"
					fi
					echo "$PACKAGE" >> $UP_LIST
					break
				fi
			done
		done
		sed -i /^$/d $UP_LIST
		upnb=$(wc -l < $UP_LIST)
		pkgs=$(ls | wc -l)
		time=$(($(date +%s) - $time))
		if [ "$upnb" == 0 ]; then
			install="n"
			_ 'System is up-to-date...'
		fi

		footer "$(emsg "$(_p \
			'%s installed package scanned in %ds' \
			'%s installed packages scanned in %ds' $pkgs \
			"<c 32>$pkgs</c>" $time)")"

		if [ "$upnb" != 0 ]; then
			blocked="$(_p \
				'%s blocked' \
				'%s blocked' $blocked_count \
				$blocked_count)"

			boldify "$(_p \
				'You have %s available upgrade (%s)' \
				'You have %s available upgrades (%s)' $upnb \
				$upnb "$blocked")"
			newline
		fi

		# Pkgs to upgrade ? Skip, let install them all or ask user
		[ "$install" == 'n' ] && exit 0
		if [ "$upnb" -gt 0 ]; then
			if [ "$install" == 'y' ]; then
				answer=0
			else
				confirm "$(_ 'Do you wish to install them now? (y/N)')"
				answer=$?
			fi
			case "$answer" in
				0)
					for pkg in $(cat $UP_LIST); do
						echo 'y' | tazpkg get-install $pkg --forced
					done
					# List is generated each time and must be cleaned so
					# tazpkg-notify doesn't find upgrades anymore.
					rm $UP_LIST; touch $UP_LIST ;;
				*)
					_ 'Leaving without any upgrades installed.'
					newline
					exit 0 ;;
			esac
		fi
		newline ;;


	bugs)
		# Show known bugs in package(s)
		cd $INSTALLED
		shift
		LIST=$@
		[ -z "$LIST" ] && LIST=$(ls)
		MSG=$(_n 'No known bugs.')

		title 'Known bugs in packages'
		for PACKAGE in $LIST; do
			BUGS=''
			EXTRAVERSION=''
			. "$PACKAGE/receipt"
			if [ -n "$BUGS" ]; then
				MSG=$(_n 'Bug list completed')
				newline
				_ 'Bugs in package "%s" version %s:' "$PACKAGE" "$VERSION$EXTRAVERSION"
				cat <<EOT
  $BUGS
EOT
			fi
		done
		footer "$MSG" ;;


	check)
		# Check installed packages set.
		#check_root $@

		# Get repositories priority list.
		look_for_priority

		cd $INSTALLED
		if [ -z "$2" -o "$2" == '--full' ]; then PACKAGES="$(ls)"; else PACKAGES="$2"; fi
		PACKAGE_PRINTED=''

		for PACKAGE in $PACKAGES; do

			if [ ! -f "$PACKAGE/receipt" ]; then
				print_pkgname
				_ 'The package installation has not completed'
				continue
			fi

			DEPENDS=''
			EXTRAVERSION=''
			. "$PACKAGE/receipt"
			if [ -s "$PACKAGE/modifiers" ]; then
				print_pkgname
				_ 'The package has been modified by:'
				awk '{print "  " $0}' "$PACKAGE/modifiers"
			fi

			MSG="$(_n 'Files lost from package:')\n"
			while read file; do
				[ -e "$file" ] && continue
				if [ -L "$file" ]; then
					MSG="$MSG  $(_n 'target of symlink')"
				fi
				print_pkgname
				echo -e "$MSG  $file"
				MSG=''
			done < "$PACKAGE/files.list"

			MSG="$(_n 'Missing dependencies for package:')\n"
			for i in $DEPENDS; do
				[ -d $i ] && continue
				[ -d $(equivalent_pkg $i) ] && continue
				print_pkgname
				echo -e "$MSG  $i"
				MSG=''
			done

			MSG="$(_n 'Dependencies loop between package and:')\n"
			ALL_DEPS=''
			check_for_deps_loop "$PACKAGE" "$DEPENDS"
		done
		[ -n "$PACKAGE_PRINTED" ] && footer

		_ 'Looking for known bugs...'
		if [ -z "$2" -o "$2" == '--full' ]; then tazpkg bugs; else tazpkg bugs "$2"; fi


		if [ -n "$full" ]; then
			separator

			title 'Mismatch checksum of installed files:'

			for PACKAGE in $PACKAGES; do
				file="$PACKAGE/$CHECKSUM"
				CONFIG_FILES=''
				. "$PACKAGE/receipt"
				[ -s "$file" ] || continue
				while read md5 f; do
					[ -f $f ] || continue
					for i in $CONFIG_FILES; do
						case "$f" in
							$i|$i/*) continue 2;;
						esac
					done
					echo "$md5  $f"
				done < "$file" | busybox $CHECKSUM -c - 2>/dev/null | \
				  grep -v OK$ | sed "s/: FAILED$//"
			done
			footer

			title 'Check file providers:'
			FILES=' '
			for PACKAGE in $PACKAGES; do
				for file in $(cat "$PACKAGE/files.list"); do
					[ -d "$file" ] && continue
					case "$FILES" in
						*\ $file\ *) continue;;
					esac
					[ $(grep "^$(echo $file | grepesc)$" */files.list 2> /dev/null | \
						wc -l) -gt 1 ] || continue
					FILES="$FILES$file "
					newline
					_ 'The following packages provide file "%s":' $file
					grep -l "^$(echo $file | grepesc)$" */files.list | \
					while read f; do
						pkg=${f%/files.list}
						if [ -f $pkg/modifiers ]; then
							overriders=$(_n '(overridden by %s)' "$(tr '\n' ' ' < $pkg/modifiers | sed 's| $||')")
						else
							overriders=''
						fi
						echo -n "  * $pkg $overriders"
						newline
					done
				done
			done
			footer

			if [ "$2" == '--full' ]; then
				title 'Alien files:'
				MSG="$(_n 'No package has installed the following files:')\n"
				find /etc /bin /sbin /lib /usr /var/www -not -type d 2>/dev/null | \
				while read file; do
					case "$file" in *\[*) continue;; esac
					grep -q "^$(echo $file | grepesc)$" */files.list && continue
					echo -e "$MSG  $file"
					MSG=''
				done
				footer
			fi
		fi
		_ 'Check completed.'; newline ;;


	block|-b)
		# Add a pkg name to the list of blocked packages.
		check_root $@
		check_for_package_on_cmdline
		newline
		if [ ! -d "$INSTALLED/$PACKAGE" ]; then
			_ 'Package "%s" is not installed.' "$PACKAGE"; exit
		fi
		if grep -qs "^$PACKAGE" $BLOCKED; then
			_ 'Package "%s" is already blocked.' "$PACKAGE"
		else
			echo "$PACKAGE" >> $BLOCKED
			# Log this activity
			. "$INSTALLED/$PACKAGE/receipt"; log_pkg Blocked
			_ 'Package "%s" blocked.' "$PACKAGE"
		fi
		newline
		;;


	unblock|-u)
		# Remove a pkg name from the list of blocked packages.
		check_root $@
		check_for_package_on_cmdline
		newline
		if [ ! -d "$INSTALLED/$PACKAGE" ]; then
			_ 'Package "%s" is not installed.' "$PACKAGE"; exit
		fi
		if grep -qs "^$PACKAGE" $BLOCKED; then
			sed -i "/^$PACKAGE\$/d" $BLOCKED
			# Log this activity
			. "$INSTALLED/$PACKAGE/receipt"; log_pkg Unblocked
			_ 'Package "%s" unblocked.' "$PACKAGE"
		else
			_ 'Package "%s" is not blocked.' "$PACKAGE"
		fi
		newline
		;;


	chblock)
		# Change package's blocked status.
		check_root $@
		check_for_package_on_cmdline
		newline
		if [ ! -d "$INSTALLED/$PACKAGE" ]; then
			_ 'Package "%s" is not installed.' "$PACKAGE"; exit
		fi
		if grep -qs "^$PACKAGE" $BLOCKED; then
			sed -i "/^$PACKAGE\$/d" $BLOCKED
			# Log this activity
			. "$INSTALLED/$PACKAGE/receipt"; log_pkg Unblocked
			_ 'Package "%s" unblocked.' "$PACKAGE"
		else
			echo "$PACKAGE" >> $BLOCKED
			# Log this activity
			. "$INSTALLED/$PACKAGE/receipt"; log_pkg Blocked
			_ 'Package "%s" blocked.' "$PACKAGE"
		fi
		newline
		;;


	get|-g)
		# Download a package with wget.
		check_root $@
		check_for_package_on_cmdline
		check_for_packages_list

		[ -n "$root" ] && ROOT="$root" && check_base_dir "$root"
		if [ -n "$rootconfig" ]; then
			if [ -n "$root" ]; then
				CACHE_DIR="$root/$CACHE_DIR"
				SAVE_CACHE_DIR="$CACHE_DIR"
				PKGS_DB="$root/$PKGS_DB"
			else
				_ 'rootconfig needs --root= option used.' >&2
				exit 1
			fi
		fi

		# Get repositories priority list.
		look_for_priority

		CURRENT_DIR="$PWD"
		cd "$CACHE_DIR"
		if check_for_package_in_list check ; then
			cd "$CACHE_DIR"
			if [ -f "$PACKAGE.tazpkg" ]; then
				_ 'Package "%s" already in the cache' "$PACKAGE"
				# Check package download was finished
				tail -c 2k "$PACKAGE.tazpkg" | fgrep -q '00000000TRAILER' || {
					_ 'Continuing package "%s" download' "$PACKAGE"
					download "$PACKAGE.tazpkg"
				}
				if [ "$($CHECKSUM "$PACKAGE.tazpkg")" != \
					"$(fgrep "  $PACKAGE.tazpkg" "$rep/packages.$SUM")" ]; then
					rm -f "$PACKAGE.tazpkg"
					download "$PACKAGE.tazpkg"
				fi
			else
				download "$PACKAGE.tazpkg"
			fi
			PACKAGE_FILE="$CACHE_DIR/$PACKAGE.tazpkg"
		elif download_get_script "$PACKAGE" "/tmp/$PACKAGE.$$" ; then
			install_package_from_get_script "/tmp/$PACKAGE.$$" "$ROOT" --get
			PACKAGE_FILE="$(ls "$PWD/$PACKAGE-*.tazpkg")"
		fi
		[ "$PWD" != "$CURRENT_DIR" ] &&
			cp -a "$PACKAGE_FILE" "$CURRENT_DIR"
		;;


	get-install|-gi)
		# Download and install a package.
		check_root $@
		check_for_package_on_cmdline
		check_for_packages_list

		DO_CHECK=''
		[ -n "$forced" ] && DO_CHECK='no'
		[ -n "$root" ] && ROOT="$root" && check_base_dir "$root"
		[ -n "$list" ] && INSTALL_LIST="$list"					# internal option

		if [ -n "$rootconfig" ]; then							# outdated?
			if [ -n "$root" ]; then
				CACHE_DIR="$root/$CACHE_DIR"
				SAVE_CACHE_DIR="$CACHE_DIR"
				PKGS_DB="$root/$PKGS_DB"
			else
				_ 'rootconfig needs --root= option used.' >&2
				exit 1
			fi
		fi

		# Get repositories priority list.
		look_for_priority

		AUTOEXEC='no'
		if ! check_for_package_in_list check; then
			CACHE_DIR="${CACHE_DIR%/*}/get"
			[ -d "$CACHE_DIR" ] || mkdir -p $CACHE_DIR
			if download_get_script "$PACKAGE" "/tmp/$PACKAGE.$$" ; then
				install_package_from_get_script "/tmp/$PACKAGE.$$" $ROOT
				exit 0
			else
				PACKAGE="get-$PACKAGE"
				AUTOEXEC="$PACKAGE"
				check_for_package_in_list
				if [ -n "$(get_installed_package_pathname "$PACKAGE" "$ROOT")" ]; then
					$AUTOEXEC $ROOT
					exit 0
				fi
			fi
		fi
		# Check if no forced install.
		if [ -z "$forced" ]; then
			check_for_installed_package $ROOT
		fi
		cd $CACHE_DIR
		if [ -f "$PACKAGE.tazpkg" ]; then
			_ 'Package "%s" already in the cache' "$PACKAGE"
			# Check package download was finished
			tail -c 2k "$PACKAGE.tazpkg" | fgrep -q '00000000TRAILER' || {
				_ 'Continuing package "%s" download' "$PACKAGE"
				download "$PACKAGE.tazpkg"
			}
			if [ "$($CHECKSUM "$PACKAGE.tazpkg")" != "$(fgrep "  $PACKAGE.tazpkg" $rep/packages.$SUM)" ]; then
				rm -f "$PACKAGE.tazpkg"
				download "$PACKAGE.tazpkg"
			fi
		else
			newline
			download "$PACKAGE.tazpkg"
		fi
		PACKAGE_FILE="$CACHE_DIR/$PACKAGE.tazpkg"
		[ -n "$rootconfig" ] && PKGS_DB="${PKGS_DB#$root}"
		install_package "$ROOT"
		[ "$AUTOEXEC" != 'no' ] && "$PACKAGE" $ROOT
		update_desktop_database $ROOT
		update_mime_database    $ROOT ;;


	clean-cache|-cc)
		# Remove all downloaded packages.
		check_root $@
		files=$(find $CACHE_DIR -name *.tazpkg | wc -l)
		size=$(du -hs $CACHE_DIR | cut -f1 | sed 's|\.0||'); [ "$files" -eq 0 ] && size="0K"

		title 'Cleaning cache directory...'
		action 'Path: %s' "$CACHE_DIR"
		rm -rf $CACHE_DIR/*
		status

		footer "$(_p \
			'%s file removed from cache (%s).' \
			'%s files removed from cache (%s).' $files \
			"$(colorize 32 "$files")" $size)"
		;;


	list-undigest)
		# list undigest URLs.
		if [ -n "$box" ]; then
			for i in $PKGS_DB/undigest/*/mirror; do
				[ -f "$i" ] || continue
				echo "$(basename "$(dirname "$i")")|$(cat "$i")"
			done
		else
			title 'Current undigest(s)'
			for i in $PKGS_DB/undigest/*/mirror; do
				if [ ! -f "$i" ]; then
					_ 'No undigest mirror found.'
					exit 1
				fi
				echo "$(basename "$(dirname "$i")")"$'\t'"$(cat "$i")"
			done
			newline
		fi
		;;


	remove-undigest)
		# remove undigest URL.
		check_root $@
		undigest="$2"
		if [ -d "$PKGS_DB/undigest/$2" ]; then
			confirm "$(_ 'Remove "%s" undigest? (y/N)' $undigest)"
			if [ $? == 0 ]; then
				action 'Removing "%s" undigest...' $undigest
				rm -rf $PKGS_DB/undigest/$2
				status
				rmdir $PKGS_DB/undigest 2>/dev/null
			fi
		else
			_ 'Undigest "%s" not found' $undigest
		fi
		;;


	add-undigest|setup-undigest)
		# Add undigest URL.
		check_root $@

		[ ! -d "$PKGS_DB/undigest" ] && mkdir "$PKGS_DB/undigest"

		undigest="$2"
		if [ -z "$undigest" ]; then
			i='1'
			while [ -d "$PKGS_DB/undigest/$i" ]; do
				i=$(($i+1))
			done
			undigest="$i"
		fi
		if [ ! -d "$PKGS_DB/undigest/$undigest" ]; then
			_ 'Creating new undigest "%s".' "$undigest"
			mkdir "$PKGS_DB/undigest/$undigest"
		fi
		setup_mirror "$PKGS_DB/undigest/$undigest" "$3"
		;;


	setup-mirror|-sm)
		# Change mirror URL.
		check_root $@
		setup_mirror $PKGS_DB $2 ;;


	reconfigure)
		# Replay post_install from receipt
		check_for_package_on_cmdline
		check_root $@

		ROOT="$root"
		if [ -d "$ROOT$INSTALLED/$PACKAGE" ]; then
			check_for_receipt $ROOT
			# Check for post_install
			if grep -q ^post_install "$ROOT$INSTALLED/$PACKAGE/receipt"; then
				. "$ROOT$INSTALLED/$PACKAGE/receipt"
				post_install $ROOT
				# Log this activity
				[ -z "$ROOT" ] && log_pkg Reconfigured
			else
				newline
				_ 'Nothing to do for package "%s".' "$PACKAGE"
			fi
		else
			newline
			_ 'Package "%s" is not installed.' "$PACKAGE"
			_ 'Install package with "%s" or "%s"' 'tazpkg install' 'tazpkg get-install'
			newline
		fi
		;;


	shell)
		# TazPkg SHell
		if [ "$(id -u)" -eq 0 ]; then
			PROMPT="\\033[1;33mtazpkg\\033[0;39m# "
		else
			PROMPT="\\033[1;33mtazpkg\\033[0;39m> "
		fi
		if [ "$2" != "--noheader" ]; then
			clear
			title 'TazPkg SHell.'
			_ "Type 'usage' to list all available commands or 'quit' or 'q' to exit."
			newline
		fi
		while true; do
			echo -en "$PROMPT"; read cmd
			case $cmd in
				q|quit)
					break ;;
				shell)
					_ 'You are already running a TazPkg SHell.' ;;
				su)
					su -c 'exec tazpkg shell --noheader' && break ;;
				"")
					continue ;;
				*)
					tazpkg $cmd ;;
			esac
		done ;;


	depends)
		# Display dependencies tree
		cd $INSTALLED
		ALL_DEPS=''
		if [ -f "$2/receipt" ]; then
			dep_scan $2 ''
		fi ;;


	rdepends)
		# Display reverse dependencies tree
		cd $INSTALLED
		ALL_DEPS=''
		if [ -f "$2/receipt" ]; then
			rdep_scan $2
		fi
		;;


	list-suggested)
		for i in $(ls -d $INSTALLED/*); do
			SUGGESTED=''
			. $i/receipt
			if [ -n "$SUGGESTED" ]; then
				if [ -z "$all" ]; then
				for s in $SUGGESTED; do
					[ -d "$INSTALLED/$s" ] && \
						SUGGESTED="$(echo -n $SUGGESTED | sed "s/$s//")"
				done
				fi
				cat <<EOT
$(boldify $(echo "$PACKAGE"):) $SUGGESTED
EOT
			fi
		done
		;;


	convert|-c)
		# convert misc package format to .tazpkg
		check_for_package_file
		shift; @@MODULES@@/convert $@
		;;


	link)
		# link a package from another slitaz installation
		PACKAGE="$2"
		if [ ! -d "$TARGET_DIR" -o \
		     ! -d "$TARGET_DIR$INSTALLED/$PACKAGE" ]; then
			_ 'Usage: tazpkg link package_name slitaz_root'
			longline "$(
				_n 'Example:'
				echo -n ' '
				_ '"%s" will use less than 100k in your running system RAM.' \
				'tazpkg link openoffice /mnt')"
			exit 1
		fi
		if [ -e "$INSTALLED/$PACKAGE" ]; then
			_ 'Package "%s" is already installed.' "$PACKAGE"
			exit 1
		fi
		ln -s "$TARGET_DIR$INSTALLED/$PACKAGE" $INSTALLED
		DEPENDS="$(. "$INSTALLED/$PACKAGE/receipt"; echo $DEPENDS)"
		MISSING=''
		for i in $DEPENDS; do
			[ -e $INSTALLED/$i ] && continue
			MISSING="$MISSING$i "
			_ 'Missing: %s' $i
		done
		if [ -n "$MISSING" ]; then
			newline
			confirm "$(_ 'Link all missing dependencies? (y/N)')"
			answer=$?
			newline
			if [ "$answer" -eq 0 ]; then
				for i in $MISSING; do
					tazpkg link $i $TARGET_DIR
				done
			else
				newline
				_ 'Leaving dependencies unresolved for package "%s"' "$PACKAGE"
				_ 'The package is installed but probably will not work.'
				newline
			fi
		fi
		. "$INSTALLED/$PACKAGE/receipt"
		if grep -q ^pre_install "$INSTALLED/$PACKAGE/receipt"; then
			pre_install
		fi
		while read path; do
			[ -e "$path" ] && continue
			while true; do
				dir="$(dirname "$path")"
				[ -e "$dir" ] && break
				path="$dir"
			done
			ln -s "$TARGET_DIR$path" "$dir"
		done < "$INSTALLED/$PACKAGE/files.list"
		if grep -q ^post_install "$INSTALLED/$PACKAGE/receipt"; then
			post_install
		fi ;;


	help|-h)
		# TazPkg help system
		shift; @@MODULES@@/help $@ ;;


	mkdb)
		# Make TazPkg database
		shift; @@MODULES@@/mkdb $@ ;;


	'')
		# Default to summary
		title "$(_ 'SliTaz package manager - Version: %s' $(colorize 34 $VERSION))"

		optlist "\
$(_ 'Installed packages:')		$(wc -l < $PKGS_DB/installed.info)
$(_ 'Installed files:')			$(cat $INSTALLED/*/files.list | wc -l)
$(_ 'Blocked packages:')		$(wc -l < $PKGS_DB/blocked-packages.list)
$(_ 'Upgradeable packages:')	$(wc -l < $PKGS_DB/packages.up)
$(
	# Per-repository stuff

	if [ -h "$PKGS_DB/fslink" ]; then
		if [ -e "$PKGS_DB/fslink/etc/slitaz/slitaz.conf" ]; then
			PKGS_DB_LINK="$PKGS_DB/fslink/$(. "$PKGS_DB/fslink/etc/slitaz/slitaz.conf"; echo "$PKGS_DB")"
		fi
	fi

	for path in $PKGS_DB $PKGS_DB/undigest/* $PKGS_DB_LINK; do
		[ ! -e "$path" ] && continue
		case "$path" in
			$PKGS_DB) repo_name='Main';;
			*/fslink/*) repo_name=$(readlink $PKGS_DB/fslink);;
			*) repo_name="$(_n 'Undigest %s' "$(basename "$path")")";;
		esac

		newline; colorize 33 "$(_n 'Repository:'; echo -e "\t$repo_name")"

		_n 'Last recharge:'; echo -en '\t'
		IDs="$path/IDs"
		if [ -e "$IDs" ]; then
			# Timezone offset as string, ex. '+0200' for EET (+2 hours)
			ohhmm="$(date +%z)"
			# Timezone offset in the seconds
			offset=$(( 60 * (60 * ${ohhmm:0:3} + ${ohhmm:3:2}) ))
			daynow=$(( ($(date         +%s) + $offset) / 86400 ))
			dayupd=$(( ($(date -r $IDs +%s) + $offset) / 86400 ))
			days=$(( $daynow - $dayupd ))
			time=$(date -r $IDs +%R)
			case $days in
				0) _ 'Today at %s.' $time;;
				1) _ 'Yesterday at %s.' $time;;
				*) _p '%d day ago.' '%d days ago.' $days $days; newline;;
			esac

			_n 'Database timestamp:'; echo -en '\t'
			date -d "@$(awk '{print $2}' "$IDs")" "+%x %R"
		else
			_ 'never.'
		fi

		if [ -e "$path/packages.info" ]; then
			_n 'Mirrored packages:'; echo -en '\t'; wc -l < "$path/packages.info"
		fi

		if [ "${path/fslink/}" != "$path" ]; then
			_n 'Linked packages:'; echo -en '\t'
			find $INSTALLED -type l | wc -l
		fi
	done
)"
		footer
		;;


	usage|*)
		# Print a short help or give usage for an unknown or empty command.
		usage ;;
esac

exit 0
