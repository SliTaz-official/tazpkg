#!/bin/sh
# Tazpkg - Tiny autonomus zone packages manager.
#
# This is a lightwight packages manager for *.tazpkg files, all written in
# SHell script. It works well with Busybox ash shell and bash. Tazpkg let you
# list, install, remove, download or get information about a package, you can
# use 'tazpkg usage' to get a list of commands with a short description. Tazpkg
# also relolv dependencies and can upgrade packages from a mirror.
#
# (C) 2007-2008 SliTaz - GNU General Public License v3.
#
# Authors : Christophe Lincoln <pankso@slitaz.org>
#           Pascal Bellard <pascal.bellard@slitaz.org>
#
VERSION=1.8

####################
# Script variables #
####################

# Packages categories.
CATEGORIES="
base-system
utilities
network
graphics
multimedia
office
development
system-tools
security
games
misc
meta"

# Initialize some variables to use words
# rater than numbers for functions and actions.
COMMAND=$1
if [ -f "$2" ]; then
	# Set pkg basename for install, extract
	PACKAGE=$(basename ${2%.tazpkg} 2>/dev/null)
else
	# Pkg name for remove, search and all other cmds
	PACKAGE=${2%.tazpkg}
fi
PACKAGE_FILE=$2
TARGET_DIR=$3
TOP_DIR=`pwd`
TMP_DIR=/tmp/tazpkg-$$-$RANDOM

# Path to tazpkg used dir and configuration files
LOCALSTATE=/var/lib/tazpkg
INSTALLED=$LOCALSTATE/installed
CACHE_DIR=/var/cache/tazpkg
MIRROR=$LOCALSTATE/mirror
PACKAGES_LIST=$LOCALSTATE/packages.list
BLOCKED=$LOCALSTATE/blocked-packages.list
DEFAULT_MIRROR="http://download.tuxfamily.org/slitaz/packages/`cat /etc/slitaz-release`/"

# Bold red warnig for upgrade.
WARNING="\\033[1;31mWARNING\\033[0;39m"

# Check if the directories and files used by Tazpkg
# exists. If not and user is root we creat them.
if test $(id -u) = 0 ; then
	if [ ! -d "$CACHE_DIR" ]; then
		mkdir -p $CACHE_DIR
	fi
	if [ ! -d "$INSTALLED" ]; then
	  mkdir -p $INSTALLED
	fi
	if [ ! -f "$LOCALSTATE/mirror" ]; then
	  echo "$DEFAULT_MIRROR" > $LOCALSTATE/mirror
	fi
fi

####################
# Script functions #
####################

# Print the usage.
usage ()
{
	echo -e "SliTaz packages manager - Version: $VERSION
\033[1mUsage: \033[0m tazpkg [command] [package|dir|pattern|list|cat|--opt] [dir|--opt]
\033[1mCommands: \033[0m
  usage         Print this short usage.
  list          List installed packages on the system by category or all.
  xhtml-list    Creat a xHTML list of installed packges.
  list-mirror   List all available packages on the mirror (--diff for new).
  info          Print informations about the package.
  desc          Print description of a package (if it exist).
  list-files    List of files installed with the package.
  search        Search for a package by pattern or name.
  search-file	Search for file(s) in all installed packages files.
  install       Install a local (*.tazpkg) package (--forced to force).
  install-list  Install all packages from a list of packages.
  remove        Remove the specified package and all installed files.
  extract       Extract a (*.tazpkg) package into a directory.
  pack          Pack an unpacked or prepared package tree.
  recharge      Recharge your packages.list from the mirror.
  repack        Creat a package archive from an installed package.
  upgrade       Upgrade all installed and listed packages on the mirror.
  block|unblock Block an installed package version or unblock it for upgrade.
  get           Download a package into the current directory.
  get-install   Download and install a package from the mirror.
  check         Verify installed packages concistancy.
  clean-cache   Clean all packages downloaded in cache directory.
  setup-mirror  Change the mirror url configuration."
}

# Status function with color (supported by Ash).
status()
{
	local CHECK=$?
	echo -en "\\033[70G[ "
	if [ $CHECK = 0 ]; then
		echo -en "\\033[1;33mOK"
	else
		echo -en "\\033[1;31mFailed"
	fi
	echo -e "\\033[0;39m ]"
	return $CHECK
}

# Check if user is root to install, or remove packages.
check_root()
{
	if test $(id -u) != 0 ; then
		echo -e "\nYou must be root to run `basename $0` with this option."
		echo -e "Please type 'su' and root password to become super-user.\n"
		exit 0
	fi
}

# Check for a package name on cmdline.
check_for_package_on_cmdline()
{
	if [ -z "$PACKAGE" ]; then
		echo -e "\nPlease specify a package name on the command line.\n"
		exit 0
	fi
}

# Check if the package (*.tazpkg) exist before installing or extracting.
check_for_package_file()
{
	if [ ! -f "$PACKAGE_FILE" ]; then
		echo -e "
Unable to find : $PACKAGE_FILE\n"
		exit 0
	fi
}

# Check for the receipt of an installed package.
check_for_receipt()
{
	if [ ! -f "$INSTALLED/$PACKAGE/receipt" ]; then
		echo -e "\nUnable to find the receipt : $INSTALLED/$PACKAGE/receipt\n"
		exit 0
	fi
}

# Check if a package is already installed.
check_for_installed_package()
{
	if [ -d "$INSTALLED/${PACKAGE%-[0-9]*}" ]; then
		echo -e "
$PACKAGE is already installed. You can use the --forced option to force
installation or remove it and reinstall.\n"
		exit 0
	fi
}

# Check for packages.list to download and install packages.
check_for_packages_list()
{
	if [ ! -f "$LOCALSTATE/packages.list" ]; then
		echo -e "
Unable to find the list : $LOCALSTATE/packages.list\n
You must probably run 'tazpkg recharge' as root to get the last list of 
packages avalaible on the mirror.\n"
		exit 0
	fi
}

# Check for a package in packages.list. Used by get and get-install to grep
# package basename.
check_for_package_in_list()
{
	if grep -q "^$PACKAGE-[0-9]" $LOCALSTATE/packages.list; then
		PACKAGE=`grep ^$PACKAGE-[0-9] $LOCALSTATE/packages.list`
	else
		echo -e "\nUnable to find : $PACKAGE in the mirrored packages list.\n"
		exit 0
	fi
}

# Download a file trying all mirrors
download()
{
	for i in $(cat $MIRROR); do
		wget $i$@ && break
	done
}

# Extract a package with cpio and gzip.
extract_package()
{
	echo -n "Extracting $PACKAGE..."
	cpio -id < $PACKAGE.tazpkg && rm -f $PACKAGE.tazpkg
	gzip -d fs.cpio.gz
	echo -n "Extracting the pseudo fs... "
	cpio -id < fs.cpio && rm fs.cpio
}

# This function install a package in the rootfs.
install_package()
{
	ROOT=$1
	if [ -n "$ROOT" ]; then
		 # get absolute path
		 ROOT=$(cd $ROOT; pwd)
	fi
	mkdir -p $TMP_DIR
	echo ""
	echo -e "\033[1mInstallation of :\033[0m $PACKAGE"
	echo "================================================================================"
	echo -n "Copying $PACKAGE... "
	cp $PACKAGE_FILE $TMP_DIR
	status
	cd $TMP_DIR
	extract_package
	SELF_INSTALL=0
	MODIFY_PACKAGES=""
	# Include temporary receipt to get the right variables.
	. $PWD/receipt
	if [ $SELF_INSTALL -ne 0 -a -n "$ROOT" ]; then
		echo -n "Checking post install dependencies... "
		[ -d "$INSTALLED/${PACKAGE%-[0-9]*}" ]
		if ! status; then
			echo "Please run 'tazpkg install $PACKAGE_FILE' and retry."
			cd .. && rm -rf $TMP_DIR
			exit 1
		fi
	fi
	# Remember modified packages
	for i in $MODIFY_PACKAGES; do
		[ -d $ROOT$INSTALLED/$i ] || continue
		grep -qs ^$PACKAGE$ $ROOT$INSTALLED/$i/modifiers && continue
		echo "$PACKAGE" >> $ROOT$INSTALLED/$i/modifiers
	done
	# Make the installed package data dir to store
	# the receipt and the files list.
	mkdir -p $ROOT$INSTALLED/$PACKAGE
	cp receipt files.list $ROOT$INSTALLED/$PACKAGE
	# Copy the description if found.
	if [ -f "description.txt" ]; then
		cp description.txt $ROOT$INSTALLED/$PACKAGE
	fi
	# Pre install commands.
	if grep -q ^pre_install $ROOT$INSTALLED/$PACKAGE/receipt; then
		pre_install $ROOT
	fi
	echo -n "Installing $PACKAGE... "
	cp -a fs/* $ROOT/
	status
	# Remove the temporary random directory.
	echo -n "Removing all tmp files... "
	cd .. && rm -rf $TMP_DIR
	status
	# Post install commands.
	if grep -q ^post_install $ROOT$INSTALLED/$PACKAGE/receipt; then
		post_install $ROOT
	fi
	cd $TOP_DIR
	echo "================================================================================"
	echo "$PACKAGE ($VERSION) is installed."
	echo ""
}

# Check for missing deps listed in a receipt packages.
check_for_deps()
{
	for i in $DEPENDS
	do
		if [ ! -d "$INSTALLED/$i" ]; then
			MISSING_PACKAGE=$i
			deps=$(($deps+1))
		fi
	done
	if [ ! "$MISSING_PACKAGE" = "" ]; then
		echo -e "\033[1mTracking dependencies for :\033[0m $PACKAGE"
		echo "================================================================================"
		for i in $DEPENDS
		do
			if [ ! -d "$INSTALLED/$i" ]; then
				MISSING_PACKAGE=$i
				echo "Missing : $MISSING_PACKAGE"
			fi
		done
		echo "================================================================================"
		echo "$deps missing package(s) to install."
	fi
}

# Install all missing deps. First ask user then install all missing deps
# from local dir, cdrom, media or from the mirror. In case we want to
# install packages from local, we need a packages.list to find the version.
install_deps()
{
	echo ""
	echo -n "Install all missing dependencies (y/N) ? "; read anser
	if [ "$anser" = "y" ]; then
		for pkg in $DEPENDS
		do
			if [ ! -d "$INSTALLED/$pkg" ]; then
				# We can install packages from a local dir by greping
				# the TAZPKG_BASENAME in the local packages.list.
				if [ -f "$TOP_DIR/packages.list" ]; then
					echo "Checking if $pkg exist in local list... "
					TAZPKG_BASENAME=`grep -e ^$pkg-[0-9] $TOP_DIR/packages.list`
					if [ -f "$TAZPKG_BASENAME.tazpkg" ]; then
						tazpkg install $TAZPKG_BASENAME.tazpkg
					fi
				# Install deps from the mirror.
				else
					if [ ! -f "$LOCALSTATE/packages.list" ]; then
						tazpkg recharge
					fi
					tazpkg get-install $pkg
				fi
			fi
		done
	else
		echo -e "\nLeaving dependencies for $PACKAGE unsolved."
		echo -e "The package is installed but will probably not work.\n"
	fi
}

# xHTML packages list header.
xhtml_header()
{
	cat > $XHTML_LIST << _EOT_
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>Installed packages list</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
	<meta name="modified" content="$DATE" />
	<meta name="generator" content="Tazpkg" />
	<style type="text/css"><!--
	body { font: 12px sans-serif, vernada, arial; margin: 0; }
	#header { background: #f0ba08; color: black; height: 50px;
		border-top: 1px solid black; border-bottom: 1px solid black; }
	#content { margin: 0px 50px 26px 50px; }
	#footer { border-top: 1px solid black; padding-top: 10px;}
	h1 { margin: 14px 0px 0px 16px; }
	pre { padding-left: 5px; }
	hr { color: white; background: white; height: 1px; border: 0; }
	--></style>
</head>
<body bgcolor="#ffffff">
<div id="header">
<h1><font color="#3e1220">Installed packages list</font></h1>
</div>
<hr />
<!-- Start content -->
<div id="content">

<p>
_packages_ packages installed - List generated on : $DATE
<p>

_EOT_
}

# xHTML content with packages infos.
xhtml_pkg_info()
{
	cat >> $XHTML_LIST << _EOT_
<h3>$PACKAGE</h3>
<pre>
Version    : $VERSION
Short desc : $SHORT_DESC
Web site   : <a href="$WEB_SITE">$WEB_SITE</a>
</pre>

_EOT_
}

# xHTML packages list footer.
xhtml_footer()
{
	cat >> $XHTML_LIST << _EOT_
<hr />
<p id="footer">
$packages packages installed - List generated on : $DATE
</p>

<!-- End content -->
</div>
</body>
</html>
_EOT_
}

###################
# Tazpkg commands #
###################

case "$COMMAND" in
	list)
		# List all installed packages or a specific category.
		#
		if [ "$2" = "blocked" ]; then
			if [ -f $BLOCKED ]; then
				LIST=`cat $BLOCKED`
			fi
			echo ""
			echo -e "\033[1mBlocked packages\033[0m"
			echo "================================================================================"
			if [ -n $LIST ];then
				echo $LIST
				echo ""
			else
				echo -e "No blocked packages found.\n"
			fi
			exit 0
		fi
		# Display the list of categories.
		if [ "$2" = "cat" -o "$2" = "categories" ]; then
			echo ""
			echo -e "\033[1mPackages categories :\033[0m"
			echo "================================================================================"
			for i in $CATEGORIES
			do
				echo $i
				categories=$(($categories+1))
			done
			echo "================================================================================"
			echo "$categories categories"
			echo ""
			exit 0
		fi
		# Check for an asked category.
		if [ -n "$2" ]; then
			ASKED_CATEGORY=$2
			echo ""
			echo -e "\033[1mInstalled packages of category :\033[0m $ASKED_CATEGORY"
			echo "================================================================================"
			for pkg in $INSTALLED/*
			do
				. $pkg/receipt
				if [ "$CATEGORY" == "$ASKED_CATEGORY" ]; then
					echo -n "$PACKAGE"
					echo -e "\033[24G $VERSION"
					packages=$(($packages+1))
				fi
			done
			echo "================================================================================"
			echo -e "$packages packages installed of category $ASKED_CATEGORY."
			echo ""
		else
			# By default list all packages and version.
			echo ""
			echo -e "\033[1mList of all installed packages\033[0m"
			echo "================================================================================"
			for pkg in $INSTALLED/*
			do
				. $pkg/receipt
				echo -n "$PACKAGE"
				echo -en "\033[24G $VERSION"
				echo -e "\033[42G $CATEGORY"
				packages=$(($packages+1))
			done
			echo "================================================================================"
			echo "$packages packages installed."
			echo ""
		fi
		;;
	xhtml-list)
		# Get infos in receipts and build list.
		DATE=`date +%Y-%m-%d\ \%H:%M:%S`
		if [ -n "$2" ]; then
			XHTML_LIST=$2
		else
			XHTML_LIST=installed-packages.html
		fi
		echo ""
		echo -e "\033[1mCreating xHTML list of installed packages\033[0m"
		echo "================================================================================"
		echo -n "Generating xHTML header..."
		xhtml_header
		status
		# Packages
		echo -n "Creating packages informations..."
		for pkg in $INSTALLED/*
		do
			. $pkg/receipt
			xhtml_pkg_info
			packages=$(($packages+1))
		done
		status
		echo -n "Generating xHTML footer..."
		xhtml_footer
		status
		# sed pkgs nb in header.
		sed -i s/'_packages_'/"$packages"/ $XHTML_LIST
		echo "================================================================================"
		echo "$XHTML_LIST created - $packages packages."
		echo ""
		;;
	list-mirror)
		# List all available packages on the mirror. Option --diff display
		# last mirrored packages diff (see recharge).
		check_for_packages_list
		if [ "$2" = "--diff" ]; then
			if [ -f "$LOCALSTATE/packages.diff" ]; then
				echo ""
				echo -e "\033[1mMirrored packages diff\033[0m"
				echo "================================================================================"
				cat $LOCALSTATE/packages.diff
				echo "================================================================================"
				pkgs=`cat $LOCALSTATE/packages.diff | wc -l`
				echo "$pkgs new packages listed on the mirror."
				echo ""
			else
				 echo -e "\nUnable to list anything, no packages.diff found."
				 echo -e "Recharge your current list to creat a first diff.\n"
			fi	
		else
			echo ""
			echo -e "\033[1mList of available packages on the mirror\033[0m"
			echo "================================================================================"
			cat $LOCALSTATE/packages.list
			echo "================================================================================"
			pkgs=`cat $LOCALSTATE/packages.list | wc -l`
			echo "$pkgs packages in the last recharged list."
			echo ""
		fi
		;;
	list-files)
		# List files installed with the package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		echo ""
		echo -e "\033[1mInstalled files with :\033[0m $PACKAGE"
		echo "================================================================================"
		cat $INSTALLED/$PACKAGE/files.list | sort
		echo "================================================================================"
		files=`cat $INSTALLED/$PACKAGE/files.list | wc -l`
		echo "$files files installed with $PACKAGE."
		echo ""
		;;
	info)
		# Informations about package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		. $INSTALLED/$PACKAGE/receipt
		echo ""
		echo -e "\033[1mTazpkg informations\033[0m
================================================================================
Package    : $PACKAGE
Version    : $VERSION
Category   : $CATEGORY
Short desc : $SHORT_DESC
Maintainer : $MAINTAINER"
		if [ ! "$DEPENDS" = "" ]; then
			echo -e "Depends    : $DEPENDS"
		fi
		if [ ! "$SUGGESTED" = "" ]; then
			echo -e "Suggested  : $SUGGESTED"
		fi
		if [ ! "$BUILD_DEPENDS" = "" ]; then
			echo -e "Build deps : $BUILD_DEPENDS"
		fi
		if [ ! "$WANTED" = "" ]; then
			echo -e "Wanted src : $WANTED"
		fi
		if [ ! "$WEB_SITE" = "" ]; then
			echo -e "Web site   : $WEB_SITE"
		fi
		echo "================================================================================"
		echo ""
		;;
	desc)
		# Display package description.txt if available.
		if [ -f "$INSTALLED/$PACKAGE/description.txt" ]; then
			echo ""
			echo -e "\033[1mDescription of :\033[0m $PACKAGE"
			echo "================================================================================"
			cat $INSTALLED/$PACKAGE/description.txt
			echo "================================================================================"
			echo ""
		else
			echo -e "\nSorry, no description available for this package.\n"
		fi
		;;
	search)
		# Search for a package by pattern or name.
		#
		if [ -z "$2" ]; then
			echo -e "\nPlease specify a pattern or a package name to search."
			echo -e "Example : 'tazpkg search paint'. \n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mSearch result for :\033[0m $2"
		echo ""
		echo "Installed packages"
		echo "================================================================================"
		list=`ls -1 $INSTALLED | grep $2`
		for pkg in $list
		do
			. $INSTALLED/$pkg/receipt
			echo -n "$PACKAGE "
			echo -en "\033[24G $VERSION"
			echo -e "\033[42G $CATEGORY"
			packages=$(($packages+1))
		done
		# Set correct ending messages.
		if [ "$packages" = "" ]; then
			echo "0 installed packages found for : $2"
			echo ""
		else
			echo "================================================================================"
			echo "$packages installed package(s) found for : $2"
			echo ""
		fi
		echo "Available packages"
		echo "================================================================================"
		if [ -f "$LOCALSTATE/packages.list" ]; then
			cat $LOCALSTATE/packages.list | grep $2
			packages=`cat $LOCALSTATE/packages.list | grep $2 | wc -l`
		else
			echo -e "
No 'packages.list' found to check for mirrored packages. For more results,
please run once 'tazpkg recharge' as root before searching.\n"
		fi
		if [ "$packages" = "0" ]; then
			echo "0 available packages found for : $2"
			echo ""
		else
			echo "================================================================================"
			echo "$packages available package(s) found for : $2"
			echo ""
		fi
		;;
	search-file)
		# Search for a file by pattern or name in all files.list.
		#
		if [ -z "$2" ]; then
			echo -e "\nPlease specify a pattern or a file name to search."
			echo -e "Example : 'tazpkg search-file libnss'. \n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mSearch result for file :\033[0m $2"
		echo "================================================================================"
		# Check all pkg files.list in search match with specify the package
		# name and the full path to the file(s).
		for pkg in $INSTALLED/*
		do
			if grep -q $2 $pkg/files.list; then
				. $pkg/receipt
				echo ""
				echo -e "\033[1mPackage $PACKAGE :\033[0m"
				grep $2 $pkg/files.list
				files=`grep $2 $pkg/files.list | wc -l`
				match=$(($match+$files))
			fi
		done
		if [ "$match" = "" ]; then
			echo "0 file found for : $2"
			echo ""
		else
			echo ""
			echo "================================================================================"
			echo "$match file(s) found for : $2"
			echo ""
		fi
		;;
	install)
		# Install .tazpkg packages.
		#
		check_root
		check_for_package_on_cmdline
		check_for_package_file
		# Check if forced install.
		DO_CHECK="yes"
		while [ -n "$3" ]; do
			case "$3" in
			--forced)
				DO_CHECK="no"
				;;
			--root=*)
				install_package ${3#--root=}
				exit $?
				;;
			*)	shift 2
				echo -e "\nUnknown option $*.\n"
				exit 1
				;;
			esac
			shift
		done
		if [ "$DO_CHECK" = "yes" ]; then
			check_for_installed_package
		fi
		install_package
		# Resolv package deps.
		check_for_deps
		if [ ! "$MISSING_PACKAGE" = "" ]; then
			install_deps
		fi
		;;
	install-list)
		# Install a set of packages from a list.
		#
		check_root
		if [ -z "$2" ]; then
			echo -e "
Please change directory (cd) to the packages repository, and specify the
list of packages to install. Example : tazpkg install-list packages.list\n"
			exit 0
		fi
		# Check if the packages list exist.
		if [ ! -f "$2" ]; then
			echo "Unable to find : $2"
			exit 0
		else
			LIST=`cat $2`
		fi
		# Install all packages.
		for pkg in $LIST
		do
			if [ "$3" = "--forced" ]; then
				tazpkg install $pkg --forced
			else
				tazpkg install $pkg
			fi
		done
		;;
	remove)
		# Remove packages.
		#
		check_root
		check_for_package_on_cmdline
		if [ ! -d "$INSTALLED/$PACKAGE" ]; then
			echo -e "\n$PACKAGE is not installed.\n"
			exit 0
		else
			ALTERED=""
			THE_PACKAGE=$PACKAGE	# altered by receipt
			for i in $(cd $INSTALLED ; ls); do
				DEPENDS=""
				. $INSTALLED/$i/receipt
				case " $(echo $DEPENDS) " in
				*\ $THE_PACKAGE\ *) ALTERED="$ALTERED $i";;
				esac
			done
			. $INSTALLED/$THE_PACKAGE/receipt
		fi
		echo ""
		if [ -n "$ALTERED" ]; then
			echo "The following packages depend on $PACKAGE :"
			for i in $ALTERED; do
				echo "  $i"
			done
		fi
		echo "Remove $PACKAGE ($VERSION) ?"
		echo -n "Please confirm uninstallation (y/N) : "; read anser
		if [ "$anser" = "y" ]; then
			echo ""
			echo -e "\033[1mRemoving :\033[0m $PACKAGE"
			echo "================================================================================"
			# Pre remove commands.
			if grep -q ^pre_remove $INSTALLED/$PACKAGE/receipt; then
				pre_remove
			fi
			echo -n "Removing all files installed..."
			for file in `cat $INSTALLED/$PACKAGE/files.list`
			do
				rm -f $file 2>/dev/null
			done
			status
			# Remove package receipt.
			echo -n "Removing package receipt..."
			rm -rf $INSTALLED/$PACKAGE
			status
			if grep -q ^post_remove $INSTALLED/$PACKAGE/receipt; then
				post_remove
			fi
			if [ -n "$ALTERED" ]; then
				echo -n "Remove packages depending on $PACKAGE"
				echo -n " (y/N) ? "; read anser
				if [ "$anser" = "y" ]; then
					for i in $ALTERED; do
						if [ -d "$INSTALLED/$i" ]; then
							tazpkg remove $i
						fi
					done
				fi
			fi
		else
			echo ""
			echo "Uninstallation of $PACKAGE cancelled."
		fi
		echo ""
		;;
	extract)
		# Extract .tazpkg cpio archive into a directory.
		#
		check_for_package_on_cmdline
		check_for_package_file
		echo ""
		echo -e "\033[1mExtracting :\033[0m $PACKAGE"
		echo "================================================================================"
		# If any directory destination is found on the cmdline
		# we creat one in the current dir using the package name.
		if [ -n "$TARGET_DIR" ]; then
			DESTDIR=$TARGET_DIR/$PACKAGE
		else
			DESTDIR=$PACKAGE
		fi
		mkdir -p $DESTDIR
		echo -n "Copying original package..."
		cp $PACKAGE_FILE $DESTDIR
		status
		cd $DESTDIR
		extract_package
		echo "================================================================================"
		echo "$PACKAGE is extracted to : $DESTDIR"
		echo ""
		;;
	repack)
		# Creat SliTaz package archive from an installed package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		eval $(grep ^VERSION= $INSTALLED/$PACKAGE/receipt)
		echo ""
		echo -e "\033[1mRepacking :\033[0m $PACKAGE-$VERSION.tazpkg"
		echo "================================================================================"
		if grep -qs ^NO_REPACK= $INSTALLED/$PACKAGE/receipt; then
			echo "Can't repack $PACKAGE"
			exit 1
		fi
		if [ -s $INSTALLED/$PACKAGE/modifiers ]; then
			echo "Can't repack, $PACKAGE files have been modified by:"
			for i in $(cat $INSTALLED/$PACKAGE/modifiers); do
				echo "  $i"
			done
			exit 1
		fi
		MISSING=""
		for i in $(sed 's,^fs,,g' < $INSTALLED/$PACKAGE/files.list); do
			[ -e "$i" ] && continue
			[ -L "$i" ] || MISSING="$MISSING $i"
		done
		if [ -n "$MISSING" ]; then
			echo "Can't repack, the following files are lost:"
			for i in $MISSING; do
				echo "  $i"
			done
			exit 1
		fi
		HERE=`pwd`
		mkdir -p $TMP_DIR && cd $TMP_DIR
		FILES="fs.cpio.gz\n"
		for i in $(ls $INSTALLED/$PACKAGE) ; do
			cp $INSTALLED/$PACKAGE/$i . && FILES="$FILES$i\n"
		done
		cpio -pd fs < files.list 2> /dev/null
		find fs | cpio -o -H newc 2> /dev/null | gzip -9 > fs.cpio.gz
		echo -e "$FILES" | cpio -o -H newc 2> /dev/null > \
			$HERE/$PACKAGE-$VERSION.tazpkg
		cd $HERE
		\rm -R $TMP_DIR
		echo "Package $PACKAGE repacked successfully."
		echo "Size : `du -sh $PACKAGE-$VERSION.tazpkg`"
		echo ""
		;;
	pack)
		# Creat SliTaz package archive using cpio and gzip.
		#
		check_for_package_on_cmdline
		cd $PACKAGE
		if [ ! -f "receipt" ]; then
			echo "Receipt is missing. Please read the documentation."
			exit 0
		else
			echo ""
			echo -e "\033[1mPacking :\033[0m $PACKAGE"
			echo "================================================================================"
			# Creat files.list with redirecting find outpout.
			echo -n "Creating the list of files..." && cd fs
			find . -type f -print > ../files.list
			find . -type l -print >> ../files.list
			cd .. && sed -i s/'^.'/''/ files.list
			status
			# Build cpio archives.
			echo -n "Compressing the fs... "
			find fs -print | cpio -o -H newc > fs.cpio
			gzip fs.cpio && rm -rf fs
			echo -n "Creating full cpio archive... "
			find . -print | cpio -o -H newc > ../$PACKAGE.tazpkg
			echo -n "Restoring original package tree... "
			gzip -d fs.cpio.gz && cpio -id < fs.cpio
			rm fs.cpio && cd ..
			echo "================================================================================"
			echo "Package $PACKAGE compressed successfully."
			echo "Size : `du -sh $PACKAGE.tazpkg`"
			echo ""
		fi
		;;
	recharge)
		# Recharge packages.list from a mirror.
		#
		check_root
		cd $LOCALSTATE
		echo ""
		if [ -f "$LOCALSTATE/packages.list" ]; then
			echo -n "Creating backup of the last packages list..."
			mv -f packages.txt packages.txt.bak 2>/dev/null
			mv -f packages.list packages.list.bak
			status
		fi
		download packages.txt
		download packages.list
		if [ -f "$LOCALSTATE/packages.list.bak" ]; then
			diff -u packages.list.bak packages.list | grep ^+[a-z] > packages.diff
			sed -i s/+// packages.diff
			echo ""
			echo -e "\033[1mMirrored packages diff\033[0m"
			echo "================================================================================"
			cat packages.diff
			if [ ! "`cat packages.diff | wc -l`" = 0 ]; then
				echo "================================================================================"
				echo "`cat packages.diff | wc -l` new packages on the mirror."
				echo ""
			else
				echo "`cat packages.diff | wc -l` new packages on the mirror."
				echo ""
			fi
		else
			echo -e "
================================================================================
Last packages.list is ready to use. Note that next time you recharge the list,
a list of differencies will be displayed to show new and upgradable packages.\n"
		fi
		;;
	upgrade)
		# Upgrade all installed packages with the new version from the mirror.
		#
		check_root
		check_for_packages_list
		cd $LOCALSTATE
		# Touch the blocked pkgs list to avoid errors and remove any old
		# upgrade list.
		touch blocked-packages.list
		rm -f upradable-packages.list
		echo ""
		echo -e "\033[1mAvalaible upgrade\033[0m"
		echo "================================================================================"
		for pkg in $INSTALLED/*
		do
			. $pkg/receipt
			# Skip specified pkgs listed in $LOCALSTATE/blocked-packages.list
			if grep -q "^$PACKAGE" $BLOCKED; then
				blocked=$(($blocked+1))
			else
				# Check if the installed package is in the current list (other
				# mirror or local).
				if grep -q "^$PACKAGE-[0-9]" packages.list; then
					# Set new pkg and version for futur comparaison
					NEW_PACKAGE=`grep ^$PACKAGE-[0-9] packages.list`
					NEW_VERSION=`echo $NEW_PACKAGE | sed s/$PACKAGE-/''/`
					# Change '-' and 'pre' to points.
					NEW_VERSION=`echo $NEW_VERSION | sed s/'-'/'.'/`
					VERSION=`echo $VERSION | sed s/'-'/'.'/`
					NEW_VERSION=`echo $NEW_VERSION | sed s/'pre'/'.'/`
					VERSION=`echo $VERSION | sed s/'pre'/'.'/`
					
					# Compare version. Upgrade are only avalaible for official
					# packages, so we control de mirror and it should be ok if
					# we just check for egality.
					if [ "$VERSION" != "$NEW_VERSION" ]; then
						# Version seems different. Check for major, minor or 
						# revision
						PKG_MAJOR=`echo $VERSION | cut -f1 -d"."`
						NEW_MAJOR=`echo $NEW_VERSION | cut -f1 -d"."`
						PKG_MINOR=`echo $VERSION | cut -f2 -d"."`
						NEW_MINOR=`echo $NEW_VERSION | cut -f2 -d"."`
						# Minor
						if [ "$NEW_MINOR" -gt "$PKG_MINOR" ]; then
							RELEASE=minor
						fi
						if [ "$NEW_MINOR" -lt "$PKG_MINOR" ]; then
							RELEASE=$WARNING
							FIXE=yes
						fi
						# Major
						if [ "$NEW_MAJOR" -gt "$PKG_MAJOR" ]; then
							RELEASE=major
							FIXE=""
						fi
						if [ "$NEW_MAJOR" -lt "$PKG_MAJOR" ]; then
							RELEASE=$WARNING
							FIXE=yes
						fi
						# Default to revision.
						if [ -z $RELEASE ]; then
							RELEASE=revision
						fi
						echo -n "$PACKAGE"
						echo -en "\033[24G $VERSION"
						echo -en "\033[38G --->"
						echo -en "\033[43G $NEW_VERSION"
						echo -en "\033[58G $CATEGORY"
						echo -e "\033[72G $RELEASE"
						up=$(($up+1))
						echo "$PACKAGE" >> upradable-packages.list
						unset RELEASE
					fi
					packages=$(($packages+1))
				fi
			fi
		done
		rm -f $tmpfile
		if [ -z $blocked ]; then
			blocked=0
		fi
		if [ ! "$up" = "" ]; then
			echo "================================================================================"
			echo "$packages installed and listed packages to consider, $up to upgrade, $blocked blocked."
			echo ""
		else
			echo "$packages installed and listed packages to consider, 0 to upgrade, $blocked blocked."
			echo ""
			exit 0
		fi
		# What to do if major or minor version is smaller.
		if [ "$FIXE" == "yes" ]; then
			echo -e "$WARNING ---> Installed package seems more recent than the mirrored one."
			echo "You can block packages using the command : 'tazpkg block package'"
			echo "Or upgrade package at you own risks."
			echo ""
		fi
		# Ask for upgrade, it can be done an other time.
		echo -n "Upgrade now (y/N) ? "; read anser
		if [ ! "$anser" = "y" ]; then
			echo -e "\nExiting. No package upgraded.\n"
			exit 0
		fi
		# If anser is yes (y). Install all new version.
		for pkg in `cat upradable-packages.list`
		do
			tazpkg get-install $pkg --forced
		done
		;;
	check)
		# check installed packages set.
		#
		check_root
		cd $INSTALLED
		for PACKAGE in `ls`; do
			DEPENDS=""
			. $PACKAGE/receipt
			if [ -s $PACKAGE/modifiers ]; then
				echo "The package $PACKAGE $VERSION has been modified by :"
				for i in $(cat $PACKAGE/modifiers); do
					echo "  $i"
				done
			fi
			MSG="Files lost from $PACKAGE $VERSION :\n"
			while read file; do
				[ -e "$file" ] && continue
				if [ -L "$file" ]; then
					MSG="$MSG  target of symlink"
				fi
				echo -e "$MSG  $file"
				MSG=""
			done < $PACKAGE/files.list
			MSG="Missing dependencies for $PACKAGE $VERSION :\n"
			for i in $DEPENDS; do
				[ -d $i ] && continue
				echo -e "$MSG  $i"
				MSG=""
			done
		done
		echo "Check completed."
		;;
	block)
		# Add a pkg name to the list of blocked packages.
		#
		check_root
		check_for_package_on_cmdline
		echo ""
		if grep -q "^$PACKAGE" $BLOCKED; then
			echo "$PACKAGE is already in the blocked packages list."
			echo ""
			exit 0
		else
			echo -n "Add $PACKAGE to : $BLOCKED..."
			echo $PACKAGE >> $BLOCKED
			status
		fi
		echo ""
		;;
	unblock)
		# Remove a pkg name to the list of blocked packages.
		#
		check_root
		check_for_package_on_cmdline
		echo ""
		if grep -q "^$PACKAGE" $BLOCKED; then
			echo -n "Removing $PACKAGE from : $BLOCKED..."
			sed -i s/$PACKAGE/''/ $BLOCKED
			sed -i '/^$/d' $BLOCKED
			status
		else
			echo "$PACKAGE is not in the blocked packages list."
			echo ""
			exit 0
		fi
		echo ""
		;;
	get)
		# Downlowd a package with wget.
		#
		check_for_package_on_cmdline
		check_for_packages_list
		check_for_package_in_list
		echo ""
		download $PACKAGE.tazpkg
		echo ""
		;;
	get-install)
		# Download and install a package.
		#
		check_root
		check_for_package_on_cmdline
		check_for_packages_list
		check_for_package_in_list
		# Check if forced install.
		if [ "$3" = "--forced" ]; then
			rm -f $CACHE_DIR/$PACKAGE.tazpkg
		else
			check_for_installed_package
		fi
		cd $CACHE_DIR
		if [ -f "$PACKAGE.tazpkg" ]; then
			echo "$PACKAGE already in the cache : $CACHE_DIR"
		else
			echo ""
			download $PACKAGE.tazpkg
		fi
		PACKAGE_FILE=$CACHE_DIR/$PACKAGE.tazpkg
		install_package
		check_for_deps
		if [ ! "$MISSING_PACKAGE" = "" ]; then
			install_deps
		fi
		;;
	clean-cache)
		# Remove all downloaded packages.
		#
		check_root
		files=`ls -1 $CACHE_DIR | wc -l`
		echo ""
		echo -e "\033[1mClean cache :\033[0m $CACHE_DIR"
		echo "================================================================================"
		echo -n "Cleaning cache directory..."
		rm -rf $CACHE_DIR/*
		status
		echo "================================================================================"
		echo "$files file(s) removed from cache."
		echo ""
		;;
	setup-mirror)
		# Change mirror URL.
		#
		check_root
		# Backup old list.
		if [ -f "$LOCALSTATE/mirror" ]; then
			cp -f $LOCALSTATE/mirror $LOCALSTATE/mirror.bak
		fi
		echo ""
		echo -e "\033[1mCurrent mirror(s)\033[0m"
		echo "================================================================================"
		echo "  `cat $MIRROR`"
		echo "
Please enter URL of the new mirror (http or ftp). You must specify the complet
address to the directory of the packages and packages.list file."
		echo ""
		echo -n "New mirror URL : "
		read NEW_MIRROR_URL
		if [ "$NEW_MIRROR_URL" = "" ]; then
			echo "Nothing as been change."
		else
			echo "Setting mirror(s) to : $NEW_MIRROR_URL"
			echo "$NEW_MIRROR_URL" > $LOCALSTATE/mirror
		fi
		echo ""
		;;
	usage|*)
		# Print a short help or give usage for an unknow or empty command.
		#
		usage
		;;
esac

exit 0
